// automatically generated by the FlatBuffers compiler, do not modify

import { flatbuffers } from "flatbuffers"
/**
 * The possible types of things that can exist.
 * Note that bullets are not treated as bodies.
 *
 * @enum {number}
 */
export namespace battlecode.schema{
export enum BodyType{
  /**
   * The hq produces miners, is also a net gun and a refinery.
   */
  HQ= 0,

  /**
   * Miners extract crude soup and bring it to the refineries.
   */
  MINER= 1,

  /**
   * Refineries turn crude soup into refined soup, and produce pollution.
   */
  REFINERY= 2,

  /**
   * Vaporators reduce pollution.
   */
  VAPORATOR= 3,

  /**
   * Design schools create landscapers.
   */
  DESIGN_SCHOOL= 4,

  /**
   * Fulfillment centers create drones.
   */
  FULFILLMENT_CENTER= 5,

  /**
   * Landscapers take dirt from adjacent (decreasing the elevation)
   * squares or deposit dirt onto adjacent squares, including
   * into water (increasing the elevation).
   */
  LANDSCAPER= 6,

  /**
   * Drones pick up any unit and drop them somewhere else.
   */
  DELIVERY_DRONE= 7,

  /**
   * Net guns shoot down drones.
   */
  NET_GUN= 8,

  /**
   * Cows produce pollution.
   */
  COW= 9
}};

/**
 * Actions that can be performed.
 * Purely aesthetic; have no actual effect on simulation.
 * (Although the simulation may want to track the 'parents' of
 * particular robots.)
 * Actions may have 'targets', which are the units on which
 * the actions were performed.
 *
 * @enum {number}
 */
export namespace battlecode.schema{
export enum Action{
  /**
   * Mines a unit of soup (miners).
   * Target: location.
   */
  MINE_SOUP= 0,

  /**
   * Deposits a unit of soup (miners).
   * Target: refinery.
   */
  DEPOSIT_SOUP= 1,

  /**
   * Refines a unit of soup (refinery).
   * Target: none.
   */
  REFINE_SOUP= 2,

  /**
   * Digs a unit of dirt (landscapers).
   * Target: location.
   */
  DIG_DIRT= 3,

  /**
   * Deposits a unit of dirt (landscapers).
   * Target: location.
   */
  DEPOSIT_DIRT= 4,

  /**
   * Picks up a unit (drones).
   * Target: unit picked up.
   */
  PICK_UNIT= 5,

  /**
   * Drops off a unit (drones).
   * Target: unit dropped off.
   */
  DROP_UNIT= 6,

  /**
   * Builds a unit.
   * Target: spawned unit
   */
  SPAWN_UNIT= 7,

  /**
   * Shoots a drone.
   * Target: drone shot.
   */
  SHOOT= 8,

  /**
   * Dies from drowning.
   * Target: none.
   */
  DIE_DROWN= 9,

  /**
   * Dies from being shot (drones).
   * Target: drone.
   */
  DIE_SHOT= 10,

  /**
   * Dies due to having too much dirt on top (buildings).
   * Target: landscaper
   */
  DIE_TOO_MUCH_DIRT= 11,

  /**
   * Dies from suicide.
   * Target: none.
   */
  DIE_SUICIDE= 12,

  /**
   * Dies due to an uncaught exception
   * Target: none
   */
  DIE_EXCEPTION= 13
}};

/**
 * An Event is a single step that needs to be processed.
 * A saved game simply consists of a long list of Events.
 * Events can be divided by either being sent separately (e.g. as separate
 * websocket messages), or by being wrapped with a GameWrapper.
 * A game consists of a series of matches; a match consists of a series of
 * rounds, and is played on a single map. Each round is a single simulation
 * step.
 *
 * @enum {number}
 */
export namespace battlecode.schema{
export enum Event{
  NONE= 0,

  /**
   * There should only be one GameHeader, at the start of the stream.
   */
  GameHeader= 1,

  /**
   * There should be one MatchHeader at the start of each match.
   */
  MatchHeader= 2,

  /**
   * A single simulation step. A round may be skipped if
   * nothing happens during its time.
   */
  Round= 3,

  /**
   * There should be one MatchFooter at the end of each simulation step.
   */
  MatchFooter= 4,

  /**
   * There should only be one GameFooter, at the end of the stream.
   */
  GameFooter= 5
}};

/**
 * A vector in two-dimensional space. Discrete space, of course.
 * Defaults to the 0 vector.
 *
 * @constructor
 */
export namespace battlecode.schema{
export class Vec {
  bb: flatbuffers.ByteBuffer|null = null;

  bb_pos:number = 0;
/**
 * @param number i
 * @param flatbuffers.ByteBuffer bb
 * @returns Vec
 */
__init(i:number, bb:flatbuffers.ByteBuffer):Vec {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

/**
 * @returns number
 */
x():number {
  return this.bb!.readInt32(this.bb_pos);
};

/**
 * @returns number
 */
y():number {
  return this.bb!.readInt32(this.bb_pos + 4);
};

/**
 * @param flatbuffers.Builder builder
 * @param number x
 * @param number y
 * @returns flatbuffers.Offset
 */
static createVec(builder:flatbuffers.Builder, x: number, y: number):flatbuffers.Offset {
  builder.prep(4, 8);
  builder.writeInt32(y);
  builder.writeInt32(x);
  return builder.offset();
};

}
}
/**
 * A table of vectors.
 *
 * @constructor
 */
export namespace battlecode.schema{
export class VecTable {
  bb: flatbuffers.ByteBuffer|null = null;

  bb_pos:number = 0;
/**
 * @param number i
 * @param flatbuffers.ByteBuffer bb
 * @returns VecTable
 */
__init(i:number, bb:flatbuffers.ByteBuffer):VecTable {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param VecTable= obj
 * @returns VecTable
 */
static getRootAsVecTable(bb:flatbuffers.ByteBuffer, obj?:VecTable):VecTable {
  return (obj || new VecTable).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param VecTable= obj
 * @returns VecTable
 */
static getSizePrefixedRootAsVecTable(bb:flatbuffers.ByteBuffer, obj?:VecTable):VecTable {
  return (obj || new VecTable).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * @param number index
 * @returns number
 */
xs(index: number):number|null {
  var offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.readInt32(this.bb!.__vector(this.bb_pos + offset) + index * 4) : 0;
};

/**
 * @returns number
 */
xsLength():number {
  var offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
};

/**
 * @returns Int32Array
 */
xsArray():Int32Array|null {
  var offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? new Int32Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
};

/**
 * @param number index
 * @returns number
 */
ys(index: number):number|null {
  var offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.readInt32(this.bb!.__vector(this.bb_pos + offset) + index * 4) : 0;
};

/**
 * @returns number
 */
ysLength():number {
  var offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
};

/**
 * @returns Int32Array
 */
ysArray():Int32Array|null {
  var offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? new Int32Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
};

/**
 * @param flatbuffers.Builder builder
 */
static startVecTable(builder:flatbuffers.Builder) {
  builder.startObject(2);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset xsOffset
 */
static addXs(builder:flatbuffers.Builder, xsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(0, xsOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param Array.<number> data
 * @returns flatbuffers.Offset
 */
static createXsVector(builder:flatbuffers.Builder, data:number[] | Uint8Array):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addInt32(data[i]);
  }
  return builder.endVector();
};

/**
 * @param flatbuffers.Builder builder
 * @param number numElems
 */
static startXsVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset ysOffset
 */
static addYs(builder:flatbuffers.Builder, ysOffset:flatbuffers.Offset) {
  builder.addFieldOffset(1, ysOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param Array.<number> data
 * @returns flatbuffers.Offset
 */
static createYsVector(builder:flatbuffers.Builder, data:number[] | Uint8Array):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addInt32(data[i]);
  }
  return builder.endVector();
};

/**
 * @param flatbuffers.Builder builder
 * @param number numElems
 */
static startYsVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
};

/**
 * @param flatbuffers.Builder builder
 * @returns flatbuffers.Offset
 */
static endVecTable(builder:flatbuffers.Builder):flatbuffers.Offset {
  var offset = builder.endObject();
  return offset;
};

static createVecTable(builder:flatbuffers.Builder, xsOffset:flatbuffers.Offset, ysOffset:flatbuffers.Offset):flatbuffers.Offset {
  VecTable.startVecTable(builder);
  VecTable.addXs(builder, xsOffset);
  VecTable.addYs(builder, ysOffset);
  return VecTable.endVecTable(builder);
}
}
}
/**
 * A table of RGB values.
 *
 * @constructor
 */
export namespace battlecode.schema{
export class RGBTable {
  bb: flatbuffers.ByteBuffer|null = null;

  bb_pos:number = 0;
/**
 * @param number i
 * @param flatbuffers.ByteBuffer bb
 * @returns RGBTable
 */
__init(i:number, bb:flatbuffers.ByteBuffer):RGBTable {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param RGBTable= obj
 * @returns RGBTable
 */
static getRootAsRGBTable(bb:flatbuffers.ByteBuffer, obj?:RGBTable):RGBTable {
  return (obj || new RGBTable).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param RGBTable= obj
 * @returns RGBTable
 */
static getSizePrefixedRootAsRGBTable(bb:flatbuffers.ByteBuffer, obj?:RGBTable):RGBTable {
  return (obj || new RGBTable).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * @param number index
 * @returns number
 */
red(index: number):number|null {
  var offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.readInt32(this.bb!.__vector(this.bb_pos + offset) + index * 4) : 0;
};

/**
 * @returns number
 */
redLength():number {
  var offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
};

/**
 * @returns Int32Array
 */
redArray():Int32Array|null {
  var offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? new Int32Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
};

/**
 * @param number index
 * @returns number
 */
green(index: number):number|null {
  var offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.readInt32(this.bb!.__vector(this.bb_pos + offset) + index * 4) : 0;
};

/**
 * @returns number
 */
greenLength():number {
  var offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
};

/**
 * @returns Int32Array
 */
greenArray():Int32Array|null {
  var offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? new Int32Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
};

/**
 * @param number index
 * @returns number
 */
blue(index: number):number|null {
  var offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? this.bb!.readInt32(this.bb!.__vector(this.bb_pos + offset) + index * 4) : 0;
};

/**
 * @returns number
 */
blueLength():number {
  var offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
};

/**
 * @returns Int32Array
 */
blueArray():Int32Array|null {
  var offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? new Int32Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
};

/**
 * @param flatbuffers.Builder builder
 */
static startRGBTable(builder:flatbuffers.Builder) {
  builder.startObject(3);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset redOffset
 */
static addRed(builder:flatbuffers.Builder, redOffset:flatbuffers.Offset) {
  builder.addFieldOffset(0, redOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param Array.<number> data
 * @returns flatbuffers.Offset
 */
static createRedVector(builder:flatbuffers.Builder, data:number[] | Uint8Array):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addInt32(data[i]);
  }
  return builder.endVector();
};

/**
 * @param flatbuffers.Builder builder
 * @param number numElems
 */
static startRedVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset greenOffset
 */
static addGreen(builder:flatbuffers.Builder, greenOffset:flatbuffers.Offset) {
  builder.addFieldOffset(1, greenOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param Array.<number> data
 * @returns flatbuffers.Offset
 */
static createGreenVector(builder:flatbuffers.Builder, data:number[] | Uint8Array):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addInt32(data[i]);
  }
  return builder.endVector();
};

/**
 * @param flatbuffers.Builder builder
 * @param number numElems
 */
static startGreenVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset blueOffset
 */
static addBlue(builder:flatbuffers.Builder, blueOffset:flatbuffers.Offset) {
  builder.addFieldOffset(2, blueOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param Array.<number> data
 * @returns flatbuffers.Offset
 */
static createBlueVector(builder:flatbuffers.Builder, data:number[] | Uint8Array):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addInt32(data[i]);
  }
  return builder.endVector();
};

/**
 * @param flatbuffers.Builder builder
 * @param number numElems
 */
static startBlueVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
};

/**
 * @param flatbuffers.Builder builder
 * @returns flatbuffers.Offset
 */
static endRGBTable(builder:flatbuffers.Builder):flatbuffers.Offset {
  var offset = builder.endObject();
  return offset;
};

static createRGBTable(builder:flatbuffers.Builder, redOffset:flatbuffers.Offset, greenOffset:flatbuffers.Offset, blueOffset:flatbuffers.Offset):flatbuffers.Offset {
  RGBTable.startRGBTable(builder);
  RGBTable.addRed(builder, redOffset);
  RGBTable.addGreen(builder, greenOffset);
  RGBTable.addBlue(builder, blueOffset);
  return RGBTable.endRGBTable(builder);
}
}
}
/**
 * A list of new bodies to be placed on the map.
 *
 * @constructor
 */
export namespace battlecode.schema{
export class SpawnedBodyTable {
  bb: flatbuffers.ByteBuffer|null = null;

  bb_pos:number = 0;
/**
 * @param number i
 * @param flatbuffers.ByteBuffer bb
 * @returns SpawnedBodyTable
 */
__init(i:number, bb:flatbuffers.ByteBuffer):SpawnedBodyTable {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param SpawnedBodyTable= obj
 * @returns SpawnedBodyTable
 */
static getRootAsSpawnedBodyTable(bb:flatbuffers.ByteBuffer, obj?:SpawnedBodyTable):SpawnedBodyTable {
  return (obj || new SpawnedBodyTable).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param SpawnedBodyTable= obj
 * @returns SpawnedBodyTable
 */
static getSizePrefixedRootAsSpawnedBodyTable(bb:flatbuffers.ByteBuffer, obj?:SpawnedBodyTable):SpawnedBodyTable {
  return (obj || new SpawnedBodyTable).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * The numeric ID of the new bodies.
 * Will never be negative.
 * There will only be one body with a particular ID at a time.
 * So, there will never be two robots with the same ID, or a robot and
 * a building with the same ID.
 *
 * @param number index
 * @returns number
 */
robotIDs(index: number):number|null {
  var offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.readInt32(this.bb!.__vector(this.bb_pos + offset) + index * 4) : 0;
};

/**
 * @returns number
 */
robotIDsLength():number {
  var offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
};

/**
 * @returns Int32Array
 */
robotIDsArray():Int32Array|null {
  var offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? new Int32Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
};

/**
 * The teams of the new bodies.
 *
 * @param number index
 * @returns number
 */
teamIDs(index: number):number|null {
  var offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.readInt8(this.bb!.__vector(this.bb_pos + offset) + index) : 0;
};

/**
 * @returns number
 */
teamIDsLength():number {
  var offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
};

/**
 * @returns Int8Array
 */
teamIDsArray():Int8Array|null {
  var offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? new Int8Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
};

/**
 * The types of the new bodies.
 *
 * @param number index
 * @returns battlecode.schema.BodyType
 */
types(index: number):battlecode.schema.BodyType|null {
  var offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? /**  */ (this.bb!.readInt8(this.bb!.__vector(this.bb_pos + offset) + index)) : /**  */ (0);
};

/**
 * @returns number
 */
typesLength():number {
  var offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
};

/**
 * @returns Int8Array
 */
typesArray():Int8Array|null {
  var offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? new Int8Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
};

/**
 * The locations of the bodies.
 *
 * @param battlecode.schema.VecTable= obj
 * @returns battlecode.schema.VecTable|null
 */
locs(obj?:battlecode.schema.VecTable):battlecode.schema.VecTable|null {
  var offset = this.bb!.__offset(this.bb_pos, 10);
  return offset ? (obj || new battlecode.schema.VecTable).__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!) : null;
};

/**
 * @param flatbuffers.Builder builder
 */
static startSpawnedBodyTable(builder:flatbuffers.Builder) {
  builder.startObject(4);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset robotIDsOffset
 */
static addRobotIDs(builder:flatbuffers.Builder, robotIDsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(0, robotIDsOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param Array.<number> data
 * @returns flatbuffers.Offset
 */
static createRobotIDsVector(builder:flatbuffers.Builder, data:number[] | Uint8Array):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addInt32(data[i]);
  }
  return builder.endVector();
};

/**
 * @param flatbuffers.Builder builder
 * @param number numElems
 */
static startRobotIDsVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset teamIDsOffset
 */
static addTeamIDs(builder:flatbuffers.Builder, teamIDsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(1, teamIDsOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param Array.<number> data
 * @returns flatbuffers.Offset
 */
static createTeamIDsVector(builder:flatbuffers.Builder, data:number[] | Uint8Array):flatbuffers.Offset {
  builder.startVector(1, data.length, 1);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addInt8(data[i]);
  }
  return builder.endVector();
};

/**
 * @param flatbuffers.Builder builder
 * @param number numElems
 */
static startTeamIDsVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(1, numElems, 1);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset typesOffset
 */
static addTypes(builder:flatbuffers.Builder, typesOffset:flatbuffers.Offset) {
  builder.addFieldOffset(2, typesOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param Array.<battlecode.schema.BodyType> data
 * @returns flatbuffers.Offset
 */
static createTypesVector(builder:flatbuffers.Builder, data:battlecode.schema.BodyType[]):flatbuffers.Offset {
  builder.startVector(1, data.length, 1);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addInt8(data[i]);
  }
  return builder.endVector();
};

/**
 * @param flatbuffers.Builder builder
 * @param number numElems
 */
static startTypesVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(1, numElems, 1);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset locsOffset
 */
static addLocs(builder:flatbuffers.Builder, locsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(3, locsOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @returns flatbuffers.Offset
 */
static endSpawnedBodyTable(builder:flatbuffers.Builder):flatbuffers.Offset {
  var offset = builder.endObject();
  return offset;
};

static createSpawnedBodyTable(builder:flatbuffers.Builder, robotIDsOffset:flatbuffers.Offset, teamIDsOffset:flatbuffers.Offset, typesOffset:flatbuffers.Offset, locsOffset:flatbuffers.Offset):flatbuffers.Offset {
  SpawnedBodyTable.startSpawnedBodyTable(builder);
  SpawnedBodyTable.addRobotIDs(builder, robotIDsOffset);
  SpawnedBodyTable.addTeamIDs(builder, teamIDsOffset);
  SpawnedBodyTable.addTypes(builder, typesOffset);
  SpawnedBodyTable.addLocs(builder, locsOffset);
  return SpawnedBodyTable.endSpawnedBodyTable(builder);
}
}
}
/**
 * A table of pollution effects
 * The pollution effect at a location is (global pollution + all additive effects) * all multiplicative effects
 *
 * @constructor
 */
export namespace battlecode.schema{
export class LocalPollutionTable {
  bb: flatbuffers.ByteBuffer|null = null;

  bb_pos:number = 0;
/**
 * @param number i
 * @param flatbuffers.ByteBuffer bb
 * @returns LocalPollutionTable
 */
__init(i:number, bb:flatbuffers.ByteBuffer):LocalPollutionTable {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param LocalPollutionTable= obj
 * @returns LocalPollutionTable
 */
static getRootAsLocalPollutionTable(bb:flatbuffers.ByteBuffer, obj?:LocalPollutionTable):LocalPollutionTable {
  return (obj || new LocalPollutionTable).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param LocalPollutionTable= obj
 * @returns LocalPollutionTable
 */
static getSizePrefixedRootAsLocalPollutionTable(bb:flatbuffers.ByteBuffer, obj?:LocalPollutionTable):LocalPollutionTable {
  return (obj || new LocalPollutionTable).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * The origin and radius of the circle defining the pollution effect.
 *
 * @param battlecode.schema.VecTable= obj
 * @returns battlecode.schema.VecTable|null
 */
locations(obj?:battlecode.schema.VecTable):battlecode.schema.VecTable|null {
  var offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? (obj || new battlecode.schema.VecTable).__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!) : null;
};

/**
 * @param number index
 * @returns number
 */
radiiSquared(index: number):number|null {
  var offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.readInt32(this.bb!.__vector(this.bb_pos + offset) + index * 4) : 0;
};

/**
 * @returns number
 */
radiiSquaredLength():number {
  var offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
};

/**
 * @returns Int32Array
 */
radiiSquaredArray():Int32Array|null {
  var offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? new Int32Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
};

/**
 * The additive amount of the pollution effect.
 *
 * @param number index
 * @returns number
 */
additiveEffects(index: number):number|null {
  var offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? this.bb!.readInt32(this.bb!.__vector(this.bb_pos + offset) + index * 4) : 0;
};

/**
 * @returns number
 */
additiveEffectsLength():number {
  var offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
};

/**
 * @returns Int32Array
 */
additiveEffectsArray():Int32Array|null {
  var offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? new Int32Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
};

/**
 * The multiplicative coefficient.
 *
 * @param number index
 * @returns number
 */
multiplicativeEffects(index: number):number|null {
  var offset = this.bb!.__offset(this.bb_pos, 10);
  return offset ? this.bb!.readFloat32(this.bb!.__vector(this.bb_pos + offset) + index * 4) : 0;
};

/**
 * @returns number
 */
multiplicativeEffectsLength():number {
  var offset = this.bb!.__offset(this.bb_pos, 10);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
};

/**
 * @returns Float32Array
 */
multiplicativeEffectsArray():Float32Array|null {
  var offset = this.bb!.__offset(this.bb_pos, 10);
  return offset ? new Float32Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
};

/**
 * @param flatbuffers.Builder builder
 */
static startLocalPollutionTable(builder:flatbuffers.Builder) {
  builder.startObject(4);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset locationsOffset
 */
static addLocations(builder:flatbuffers.Builder, locationsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(0, locationsOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset radiiSquaredOffset
 */
static addRadiiSquared(builder:flatbuffers.Builder, radiiSquaredOffset:flatbuffers.Offset) {
  builder.addFieldOffset(1, radiiSquaredOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param Array.<number> data
 * @returns flatbuffers.Offset
 */
static createRadiiSquaredVector(builder:flatbuffers.Builder, data:number[] | Uint8Array):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addInt32(data[i]);
  }
  return builder.endVector();
};

/**
 * @param flatbuffers.Builder builder
 * @param number numElems
 */
static startRadiiSquaredVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset additiveEffectsOffset
 */
static addAdditiveEffects(builder:flatbuffers.Builder, additiveEffectsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(2, additiveEffectsOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param Array.<number> data
 * @returns flatbuffers.Offset
 */
static createAdditiveEffectsVector(builder:flatbuffers.Builder, data:number[] | Uint8Array):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addInt32(data[i]);
  }
  return builder.endVector();
};

/**
 * @param flatbuffers.Builder builder
 * @param number numElems
 */
static startAdditiveEffectsVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset multiplicativeEffectsOffset
 */
static addMultiplicativeEffects(builder:flatbuffers.Builder, multiplicativeEffectsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(3, multiplicativeEffectsOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param Array.<number> data
 * @returns flatbuffers.Offset
 */
static createMultiplicativeEffectsVector(builder:flatbuffers.Builder, data:number[] | Uint8Array):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addFloat32(data[i]);
  }
  return builder.endVector();
};

/**
 * @param flatbuffers.Builder builder
 * @param number numElems
 */
static startMultiplicativeEffectsVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
};

/**
 * @param flatbuffers.Builder builder
 * @returns flatbuffers.Offset
 */
static endLocalPollutionTable(builder:flatbuffers.Builder):flatbuffers.Offset {
  var offset = builder.endObject();
  return offset;
};

static createLocalPollutionTable(builder:flatbuffers.Builder, locationsOffset:flatbuffers.Offset, radiiSquaredOffset:flatbuffers.Offset, additiveEffectsOffset:flatbuffers.Offset, multiplicativeEffectsOffset:flatbuffers.Offset):flatbuffers.Offset {
  LocalPollutionTable.startLocalPollutionTable(builder);
  LocalPollutionTable.addLocations(builder, locationsOffset);
  LocalPollutionTable.addRadiiSquared(builder, radiiSquaredOffset);
  LocalPollutionTable.addAdditiveEffects(builder, additiveEffectsOffset);
  LocalPollutionTable.addMultiplicativeEffects(builder, multiplicativeEffectsOffset);
  return LocalPollutionTable.endLocalPollutionTable(builder);
}
}
}
/**
 * The map a round is played on.
 *
 * @constructor
 */
export namespace battlecode.schema{
export class GameMap {
  bb: flatbuffers.ByteBuffer|null = null;

  bb_pos:number = 0;
/**
 * @param number i
 * @param flatbuffers.ByteBuffer bb
 * @returns GameMap
 */
__init(i:number, bb:flatbuffers.ByteBuffer):GameMap {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param GameMap= obj
 * @returns GameMap
 */
static getRootAsGameMap(bb:flatbuffers.ByteBuffer, obj?:GameMap):GameMap {
  return (obj || new GameMap).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param GameMap= obj
 * @returns GameMap
 */
static getSizePrefixedRootAsGameMap(bb:flatbuffers.ByteBuffer, obj?:GameMap):GameMap {
  return (obj || new GameMap).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * The name of a map.
 *
 * @param flatbuffers.Encoding= optionalEncoding
 * @returns string|Uint8Array|null
 */
name():string|null
name(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
name(optionalEncoding?:any):string|Uint8Array|null {
  var offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
};

/**
 * The bottom corner of the map.
 *
 * @param battlecode.schema.Vec= obj
 * @returns battlecode.schema.Vec|null
 */
minCorner(obj?:battlecode.schema.Vec):battlecode.schema.Vec|null {
  var offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? (obj || new battlecode.schema.Vec).__init(this.bb_pos + offset, this.bb!) : null;
};

/**
 * The top corner of the map.
 *
 * @param battlecode.schema.Vec= obj
 * @returns battlecode.schema.Vec|null
 */
maxCorner(obj?:battlecode.schema.Vec):battlecode.schema.Vec|null {
  var offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? (obj || new battlecode.schema.Vec).__init(this.bb_pos + offset, this.bb!) : null;
};

/**
 * The bodies on the map.
 *
 * @param battlecode.schema.SpawnedBodyTable= obj
 * @returns battlecode.schema.SpawnedBodyTable|null
 */
bodies(obj?:battlecode.schema.SpawnedBodyTable):battlecode.schema.SpawnedBodyTable|null {
  var offset = this.bb!.__offset(this.bb_pos, 10);
  return offset ? (obj || new battlecode.schema.SpawnedBodyTable).__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!) : null;
};

/**
 * The random seed of the map.
 *
 * @returns number
 */
randomSeed():number {
  var offset = this.bb!.__offset(this.bb_pos, 12);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
};

/**
 * The dirt levels.
 *
 * @param number index
 * @returns number
 */
dirt(index: number):number|null {
  var offset = this.bb!.__offset(this.bb_pos, 14);
  return offset ? this.bb!.readInt32(this.bb!.__vector(this.bb_pos + offset) + index * 4) : 0;
};

/**
 * @returns number
 */
dirtLength():number {
  var offset = this.bb!.__offset(this.bb_pos, 14);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
};

/**
 * @returns Int32Array
 */
dirtArray():Int32Array|null {
  var offset = this.bb!.__offset(this.bb_pos, 14);
  return offset ? new Int32Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
};

/**
 * The water levels (above dirt).
 *
 * @param number index
 * @returns boolean
 */
water(index: number):boolean|null {
  var offset = this.bb!.__offset(this.bb_pos, 16);
  return offset ? !!this.bb!.readInt8(this.bb!.__vector(this.bb_pos + offset) + index) : false;
};

/**
 * @returns number
 */
waterLength():number {
  var offset = this.bb!.__offset(this.bb_pos, 16);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
};

/**
 * @returns Int8Array
 */
waterArray():Int8Array|null {
  var offset = this.bb!.__offset(this.bb_pos, 16);
  return offset ? new Int8Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
};

/**
 * The pollution levels.
 *
 * @param number index
 * @returns number
 */
pollution(index: number):number|null {
  var offset = this.bb!.__offset(this.bb_pos, 18);
  return offset ? this.bb!.readInt32(this.bb!.__vector(this.bb_pos + offset) + index * 4) : 0;
};

/**
 * @returns number
 */
pollutionLength():number {
  var offset = this.bb!.__offset(this.bb_pos, 18);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
};

/**
 * @returns Int32Array
 */
pollutionArray():Int32Array|null {
  var offset = this.bb!.__offset(this.bb_pos, 18);
  return offset ? new Int32Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
};

/**
 * The amount of crude soup to be mined.
 *
 * @param number index
 * @returns number
 */
soup(index: number):number|null {
  var offset = this.bb!.__offset(this.bb_pos, 20);
  return offset ? this.bb!.readInt32(this.bb!.__vector(this.bb_pos + offset) + index * 4) : 0;
};

/**
 * @returns number
 */
soupLength():number {
  var offset = this.bb!.__offset(this.bb_pos, 20);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
};

/**
 * @returns Int32Array
 */
soupArray():Int32Array|null {
  var offset = this.bb!.__offset(this.bb_pos, 20);
  return offset ? new Int32Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
};

/**
 * The initial water level.
 *
 * @returns number
 */
initialWater():number {
  var offset = this.bb!.__offset(this.bb_pos, 22);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
};

/**
 * @param flatbuffers.Builder builder
 */
static startGameMap(builder:flatbuffers.Builder) {
  builder.startObject(10);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset nameOffset
 */
static addName(builder:flatbuffers.Builder, nameOffset:flatbuffers.Offset) {
  builder.addFieldOffset(0, nameOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset minCornerOffset
 */
static addMinCorner(builder:flatbuffers.Builder, minCornerOffset:flatbuffers.Offset) {
  builder.addFieldStruct(1, minCornerOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset maxCornerOffset
 */
static addMaxCorner(builder:flatbuffers.Builder, maxCornerOffset:flatbuffers.Offset) {
  builder.addFieldStruct(2, maxCornerOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset bodiesOffset
 */
static addBodies(builder:flatbuffers.Builder, bodiesOffset:flatbuffers.Offset) {
  builder.addFieldOffset(3, bodiesOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param number randomSeed
 */
static addRandomSeed(builder:flatbuffers.Builder, randomSeed:number) {
  builder.addFieldInt32(4, randomSeed, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset dirtOffset
 */
static addDirt(builder:flatbuffers.Builder, dirtOffset:flatbuffers.Offset) {
  builder.addFieldOffset(5, dirtOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param Array.<number> data
 * @returns flatbuffers.Offset
 */
static createDirtVector(builder:flatbuffers.Builder, data:number[] | Uint8Array):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addInt32(data[i]);
  }
  return builder.endVector();
};

/**
 * @param flatbuffers.Builder builder
 * @param number numElems
 */
static startDirtVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset waterOffset
 */
static addWater(builder:flatbuffers.Builder, waterOffset:flatbuffers.Offset) {
  builder.addFieldOffset(6, waterOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param Array.<boolean> data
 * @returns flatbuffers.Offset
 */
static createWaterVector(builder:flatbuffers.Builder, data:boolean[]):flatbuffers.Offset {
  builder.startVector(1, data.length, 1);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addInt8(+data[i]);
  }
  return builder.endVector();
};

/**
 * @param flatbuffers.Builder builder
 * @param number numElems
 */
static startWaterVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(1, numElems, 1);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset pollutionOffset
 */
static addPollution(builder:flatbuffers.Builder, pollutionOffset:flatbuffers.Offset) {
  builder.addFieldOffset(7, pollutionOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param Array.<number> data
 * @returns flatbuffers.Offset
 */
static createPollutionVector(builder:flatbuffers.Builder, data:number[] | Uint8Array):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addInt32(data[i]);
  }
  return builder.endVector();
};

/**
 * @param flatbuffers.Builder builder
 * @param number numElems
 */
static startPollutionVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset soupOffset
 */
static addSoup(builder:flatbuffers.Builder, soupOffset:flatbuffers.Offset) {
  builder.addFieldOffset(8, soupOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param Array.<number> data
 * @returns flatbuffers.Offset
 */
static createSoupVector(builder:flatbuffers.Builder, data:number[] | Uint8Array):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addInt32(data[i]);
  }
  return builder.endVector();
};

/**
 * @param flatbuffers.Builder builder
 * @param number numElems
 */
static startSoupVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
};

/**
 * @param flatbuffers.Builder builder
 * @param number initialWater
 */
static addInitialWater(builder:flatbuffers.Builder, initialWater:number) {
  builder.addFieldInt32(9, initialWater, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @returns flatbuffers.Offset
 */
static endGameMap(builder:flatbuffers.Builder):flatbuffers.Offset {
  var offset = builder.endObject();
  return offset;
};

static createGameMap(builder:flatbuffers.Builder, nameOffset:flatbuffers.Offset, minCornerOffset:flatbuffers.Offset, maxCornerOffset:flatbuffers.Offset, bodiesOffset:flatbuffers.Offset, randomSeed:number, dirtOffset:flatbuffers.Offset, waterOffset:flatbuffers.Offset, pollutionOffset:flatbuffers.Offset, soupOffset:flatbuffers.Offset, initialWater:number):flatbuffers.Offset {
  GameMap.startGameMap(builder);
  GameMap.addName(builder, nameOffset);
  GameMap.addMinCorner(builder, minCornerOffset);
  GameMap.addMaxCorner(builder, maxCornerOffset);
  GameMap.addBodies(builder, bodiesOffset);
  GameMap.addRandomSeed(builder, randomSeed);
  GameMap.addDirt(builder, dirtOffset);
  GameMap.addWater(builder, waterOffset);
  GameMap.addPollution(builder, pollutionOffset);
  GameMap.addSoup(builder, soupOffset);
  GameMap.addInitialWater(builder, initialWater);
  return GameMap.endGameMap(builder);
}
}
}
/**
 * Metadata about all bodies of a particular type.
 *
 * @constructor
 */
export namespace battlecode.schema{
export class BodyTypeMetadata {
  bb: flatbuffers.ByteBuffer|null = null;

  bb_pos:number = 0;
/**
 * @param number i
 * @param flatbuffers.ByteBuffer bb
 * @returns BodyTypeMetadata
 */
__init(i:number, bb:flatbuffers.ByteBuffer):BodyTypeMetadata {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param BodyTypeMetadata= obj
 * @returns BodyTypeMetadata
 */
static getRootAsBodyTypeMetadata(bb:flatbuffers.ByteBuffer, obj?:BodyTypeMetadata):BodyTypeMetadata {
  return (obj || new BodyTypeMetadata).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param BodyTypeMetadata= obj
 * @returns BodyTypeMetadata
 */
static getSizePrefixedRootAsBodyTypeMetadata(bb:flatbuffers.ByteBuffer, obj?:BodyTypeMetadata):BodyTypeMetadata {
  return (obj || new BodyTypeMetadata).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * The relevant type.
 *
 * @returns battlecode.schema.BodyType
 */
type():battlecode.schema.BodyType {
  var offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? /**  */ (this.bb!.readInt8(this.bb_pos + offset)) : battlecode.schema.BodyType.HQ;
};

/**
 * The spawn source.
 *
 * @returns battlecode.schema.BodyType
 */
spawnSource():battlecode.schema.BodyType {
  var offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? /**  */ (this.bb!.readInt8(this.bb_pos + offset)) : battlecode.schema.BodyType.HQ;
};

/**
 * The cost of the type, in soup.
 *
 * @returns number
 */
cost():number {
  var offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
};

/**
 * The maximum amount of dirt the type can carry.
 *
 * @returns number
 */
dirtLimit():number {
  var offset = this.bb!.__offset(this.bb_pos, 10);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
};

/**
 * The maximum amount of soup the type can carry.
 *
 * @returns number
 */
soupLimit():number {
  var offset = this.bb!.__offset(this.bb_pos, 12);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
};

/**
 * The number of cooldowns between every two actions, for pollution 0.
 *
 * @returns number
 */
actionCooldown():number {
  var offset = this.bb!.__offset(this.bb_pos, 14);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
};

/**
 * The maximum distance squared this type can sense other robots.
 *
 * @returns number
 */
sensorRadiusSquared():number {
  var offset = this.bb!.__offset(this.bb_pos, 16);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
};

/**
 * The radius squared of local pollution effects.
 *
 * @returns number
 */
pollutionRadiusSquared():number {
  var offset = this.bb!.__offset(this.bb_pos, 18);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
};

/**
 * The amount of pollution created when refining soup locally.
 *
 * @returns number
 */
localPollutionAdditiveEffect():number {
  var offset = this.bb!.__offset(this.bb_pos, 20);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
};

/**
 * The fraction that the local pollution is multiplied by around vaporators.
 *
 * @returns number
 */
localPollutionMultiplicativeEffect():number {
  var offset = this.bb!.__offset(this.bb_pos, 22);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
};

/**
 * The amount of global pollution this type creates.
 *
 * @returns number
 */
globalPollutionAmount():number {
  var offset = this.bb!.__offset(this.bb_pos, 24);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
};

/**
 * The maximum amount of soup this type processes every turn.
 *
 * @returns number
 */
maxSoupProduced():number {
  var offset = this.bb!.__offset(this.bb_pos, 26);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
};

/**
 * The bytecode limit of this type.
 *
 * @returns number
 */
bytecodeLimit():number {
  var offset = this.bb!.__offset(this.bb_pos, 28);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
};

/**
 * @param flatbuffers.Builder builder
 */
static startBodyTypeMetadata(builder:flatbuffers.Builder) {
  builder.startObject(13);
};

/**
 * @param flatbuffers.Builder builder
 * @param battlecode.schema.BodyType type
 */
static addType(builder:flatbuffers.Builder, type:battlecode.schema.BodyType) {
  builder.addFieldInt8(0, type, battlecode.schema.BodyType.HQ);
};

/**
 * @param flatbuffers.Builder builder
 * @param battlecode.schema.BodyType spawnSource
 */
static addSpawnSource(builder:flatbuffers.Builder, spawnSource:battlecode.schema.BodyType) {
  builder.addFieldInt8(1, spawnSource, battlecode.schema.BodyType.HQ);
};

/**
 * @param flatbuffers.Builder builder
 * @param number cost
 */
static addCost(builder:flatbuffers.Builder, cost:number) {
  builder.addFieldInt32(2, cost, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param number dirtLimit
 */
static addDirtLimit(builder:flatbuffers.Builder, dirtLimit:number) {
  builder.addFieldInt32(3, dirtLimit, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param number soupLimit
 */
static addSoupLimit(builder:flatbuffers.Builder, soupLimit:number) {
  builder.addFieldInt32(4, soupLimit, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param number actionCooldown
 */
static addActionCooldown(builder:flatbuffers.Builder, actionCooldown:number) {
  builder.addFieldFloat32(5, actionCooldown, 0.0);
};

/**
 * @param flatbuffers.Builder builder
 * @param number sensorRadiusSquared
 */
static addSensorRadiusSquared(builder:flatbuffers.Builder, sensorRadiusSquared:number) {
  builder.addFieldInt32(6, sensorRadiusSquared, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param number pollutionRadiusSquared
 */
static addPollutionRadiusSquared(builder:flatbuffers.Builder, pollutionRadiusSquared:number) {
  builder.addFieldInt32(7, pollutionRadiusSquared, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param number localPollutionAdditiveEffect
 */
static addLocalPollutionAdditiveEffect(builder:flatbuffers.Builder, localPollutionAdditiveEffect:number) {
  builder.addFieldInt32(8, localPollutionAdditiveEffect, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param number localPollutionMultiplicativeEffect
 */
static addLocalPollutionMultiplicativeEffect(builder:flatbuffers.Builder, localPollutionMultiplicativeEffect:number) {
  builder.addFieldFloat32(9, localPollutionMultiplicativeEffect, 0.0);
};

/**
 * @param flatbuffers.Builder builder
 * @param number globalPollutionAmount
 */
static addGlobalPollutionAmount(builder:flatbuffers.Builder, globalPollutionAmount:number) {
  builder.addFieldInt32(10, globalPollutionAmount, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param number maxSoupProduced
 */
static addMaxSoupProduced(builder:flatbuffers.Builder, maxSoupProduced:number) {
  builder.addFieldInt32(11, maxSoupProduced, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param number bytecodeLimit
 */
static addBytecodeLimit(builder:flatbuffers.Builder, bytecodeLimit:number) {
  builder.addFieldInt32(12, bytecodeLimit, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @returns flatbuffers.Offset
 */
static endBodyTypeMetadata(builder:flatbuffers.Builder):flatbuffers.Offset {
  var offset = builder.endObject();
  return offset;
};

static createBodyTypeMetadata(builder:flatbuffers.Builder, type:battlecode.schema.BodyType, spawnSource:battlecode.schema.BodyType, cost:number, dirtLimit:number, soupLimit:number, actionCooldown:number, sensorRadiusSquared:number, pollutionRadiusSquared:number, localPollutionAdditiveEffect:number, localPollutionMultiplicativeEffect:number, globalPollutionAmount:number, maxSoupProduced:number, bytecodeLimit:number):flatbuffers.Offset {
  BodyTypeMetadata.startBodyTypeMetadata(builder);
  BodyTypeMetadata.addType(builder, type);
  BodyTypeMetadata.addSpawnSource(builder, spawnSource);
  BodyTypeMetadata.addCost(builder, cost);
  BodyTypeMetadata.addDirtLimit(builder, dirtLimit);
  BodyTypeMetadata.addSoupLimit(builder, soupLimit);
  BodyTypeMetadata.addActionCooldown(builder, actionCooldown);
  BodyTypeMetadata.addSensorRadiusSquared(builder, sensorRadiusSquared);
  BodyTypeMetadata.addPollutionRadiusSquared(builder, pollutionRadiusSquared);
  BodyTypeMetadata.addLocalPollutionAdditiveEffect(builder, localPollutionAdditiveEffect);
  BodyTypeMetadata.addLocalPollutionMultiplicativeEffect(builder, localPollutionMultiplicativeEffect);
  BodyTypeMetadata.addGlobalPollutionAmount(builder, globalPollutionAmount);
  BodyTypeMetadata.addMaxSoupProduced(builder, maxSoupProduced);
  BodyTypeMetadata.addBytecodeLimit(builder, bytecodeLimit);
  return BodyTypeMetadata.endBodyTypeMetadata(builder);
}
}
}
/**
 * Data relevant to a particular team.
 *
 * @constructor
 */
export namespace battlecode.schema{
export class TeamData {
  bb: flatbuffers.ByteBuffer|null = null;

  bb_pos:number = 0;
/**
 * @param number i
 * @param flatbuffers.ByteBuffer bb
 * @returns TeamData
 */
__init(i:number, bb:flatbuffers.ByteBuffer):TeamData {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param TeamData= obj
 * @returns TeamData
 */
static getRootAsTeamData(bb:flatbuffers.ByteBuffer, obj?:TeamData):TeamData {
  return (obj || new TeamData).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param TeamData= obj
 * @returns TeamData
 */
static getSizePrefixedRootAsTeamData(bb:flatbuffers.ByteBuffer, obj?:TeamData):TeamData {
  return (obj || new TeamData).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * The name of the team.
 *
 * @param flatbuffers.Encoding= optionalEncoding
 * @returns string|Uint8Array|null
 */
name():string|null
name(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
name(optionalEncoding?:any):string|Uint8Array|null {
  var offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
};

/**
 * The java package the team uses.
 *
 * @param flatbuffers.Encoding= optionalEncoding
 * @returns string|Uint8Array|null
 */
packageName():string|null
packageName(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
packageName(optionalEncoding?:any):string|Uint8Array|null {
  var offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
};

/**
 * The ID of the team this data pertains to.
 *
 * @returns number
 */
teamID():number {
  var offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? this.bb!.readInt8(this.bb_pos + offset) : 0;
};

/**
 * @param flatbuffers.Builder builder
 */
static startTeamData(builder:flatbuffers.Builder) {
  builder.startObject(3);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset nameOffset
 */
static addName(builder:flatbuffers.Builder, nameOffset:flatbuffers.Offset) {
  builder.addFieldOffset(0, nameOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset packageNameOffset
 */
static addPackageName(builder:flatbuffers.Builder, packageNameOffset:flatbuffers.Offset) {
  builder.addFieldOffset(1, packageNameOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param number teamID
 */
static addTeamID(builder:flatbuffers.Builder, teamID:number) {
  builder.addFieldInt8(2, teamID, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @returns flatbuffers.Offset
 */
static endTeamData(builder:flatbuffers.Builder):flatbuffers.Offset {
  var offset = builder.endObject();
  return offset;
};

static createTeamData(builder:flatbuffers.Builder, nameOffset:flatbuffers.Offset, packageNameOffset:flatbuffers.Offset, teamID:number):flatbuffers.Offset {
  TeamData.startTeamData(builder);
  TeamData.addName(builder, nameOffset);
  TeamData.addPackageName(builder, packageNameOffset);
  TeamData.addTeamID(builder, teamID);
  return TeamData.endTeamData(builder);
}
}
}
/**
 * The first event sent in the game. Contains all metadata about the game.
 *
 * @constructor
 */
export namespace battlecode.schema{
export class GameHeader {
  bb: flatbuffers.ByteBuffer|null = null;

  bb_pos:number = 0;
/**
 * @param number i
 * @param flatbuffers.ByteBuffer bb
 * @returns GameHeader
 */
__init(i:number, bb:flatbuffers.ByteBuffer):GameHeader {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param GameHeader= obj
 * @returns GameHeader
 */
static getRootAsGameHeader(bb:flatbuffers.ByteBuffer, obj?:GameHeader):GameHeader {
  return (obj || new GameHeader).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param GameHeader= obj
 * @returns GameHeader
 */
static getSizePrefixedRootAsGameHeader(bb:flatbuffers.ByteBuffer, obj?:GameHeader):GameHeader {
  return (obj || new GameHeader).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * The version of the spec this game complies with.
 *
 * @param flatbuffers.Encoding= optionalEncoding
 * @returns string|Uint8Array|null
 */
specVersion():string|null
specVersion(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
specVersion(optionalEncoding?:any):string|Uint8Array|null {
  var offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
};

/**
 * The teams participating in the game.
 *
 * @param number index
 * @param battlecode.schema.TeamData= obj
 * @returns battlecode.schema.TeamData
 */
teams(index: number, obj?:battlecode.schema.TeamData):battlecode.schema.TeamData|null {
  var offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? (obj || new battlecode.schema.TeamData).__init(this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4), this.bb!) : null;
};

/**
 * @returns number
 */
teamsLength():number {
  var offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
};

/**
 * Information about all body types in the game.
 *
 * @param number index
 * @param battlecode.schema.BodyTypeMetadata= obj
 * @returns battlecode.schema.BodyTypeMetadata
 */
bodyTypeMetadata(index: number, obj?:battlecode.schema.BodyTypeMetadata):battlecode.schema.BodyTypeMetadata|null {
  var offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? (obj || new battlecode.schema.BodyTypeMetadata).__init(this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4), this.bb!) : null;
};

/**
 * @returns number
 */
bodyTypeMetadataLength():number {
  var offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
};

/**
 * @param flatbuffers.Builder builder
 */
static startGameHeader(builder:flatbuffers.Builder) {
  builder.startObject(3);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset specVersionOffset
 */
static addSpecVersion(builder:flatbuffers.Builder, specVersionOffset:flatbuffers.Offset) {
  builder.addFieldOffset(0, specVersionOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset teamsOffset
 */
static addTeams(builder:flatbuffers.Builder, teamsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(1, teamsOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param Array.<flatbuffers.Offset> data
 * @returns flatbuffers.Offset
 */
static createTeamsVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]);
  }
  return builder.endVector();
};

/**
 * @param flatbuffers.Builder builder
 * @param number numElems
 */
static startTeamsVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset bodyTypeMetadataOffset
 */
static addBodyTypeMetadata(builder:flatbuffers.Builder, bodyTypeMetadataOffset:flatbuffers.Offset) {
  builder.addFieldOffset(2, bodyTypeMetadataOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param Array.<flatbuffers.Offset> data
 * @returns flatbuffers.Offset
 */
static createBodyTypeMetadataVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]);
  }
  return builder.endVector();
};

/**
 * @param flatbuffers.Builder builder
 * @param number numElems
 */
static startBodyTypeMetadataVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
};

/**
 * @param flatbuffers.Builder builder
 * @returns flatbuffers.Offset
 */
static endGameHeader(builder:flatbuffers.Builder):flatbuffers.Offset {
  var offset = builder.endObject();
  return offset;
};

static createGameHeader(builder:flatbuffers.Builder, specVersionOffset:flatbuffers.Offset, teamsOffset:flatbuffers.Offset, bodyTypeMetadataOffset:flatbuffers.Offset):flatbuffers.Offset {
  GameHeader.startGameHeader(builder);
  GameHeader.addSpecVersion(builder, specVersionOffset);
  GameHeader.addTeams(builder, teamsOffset);
  GameHeader.addBodyTypeMetadata(builder, bodyTypeMetadataOffset);
  return GameHeader.endGameHeader(builder);
}
}
}
/**
 * The final event sent in the game.
 *
 * @constructor
 */
export namespace battlecode.schema{
export class GameFooter {
  bb: flatbuffers.ByteBuffer|null = null;

  bb_pos:number = 0;
/**
 * @param number i
 * @param flatbuffers.ByteBuffer bb
 * @returns GameFooter
 */
__init(i:number, bb:flatbuffers.ByteBuffer):GameFooter {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param GameFooter= obj
 * @returns GameFooter
 */
static getRootAsGameFooter(bb:flatbuffers.ByteBuffer, obj?:GameFooter):GameFooter {
  return (obj || new GameFooter).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param GameFooter= obj
 * @returns GameFooter
 */
static getSizePrefixedRootAsGameFooter(bb:flatbuffers.ByteBuffer, obj?:GameFooter):GameFooter {
  return (obj || new GameFooter).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * The ID of the winning team of the game.
 *
 * @returns number
 */
winner():number {
  var offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.readInt8(this.bb_pos + offset) : 0;
};

/**
 * @param flatbuffers.Builder builder
 */
static startGameFooter(builder:flatbuffers.Builder) {
  builder.startObject(1);
};

/**
 * @param flatbuffers.Builder builder
 * @param number winner
 */
static addWinner(builder:flatbuffers.Builder, winner:number) {
  builder.addFieldInt8(0, winner, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @returns flatbuffers.Offset
 */
static endGameFooter(builder:flatbuffers.Builder):flatbuffers.Offset {
  var offset = builder.endObject();
  return offset;
};

static createGameFooter(builder:flatbuffers.Builder, winner:number):flatbuffers.Offset {
  GameFooter.startGameFooter(builder);
  GameFooter.addWinner(builder, winner);
  return GameFooter.endGameFooter(builder);
}
}
}
/**
 * Sent to start a match.
 *
 * @constructor
 */
export namespace battlecode.schema{
export class MatchHeader {
  bb: flatbuffers.ByteBuffer|null = null;

  bb_pos:number = 0;
/**
 * @param number i
 * @param flatbuffers.ByteBuffer bb
 * @returns MatchHeader
 */
__init(i:number, bb:flatbuffers.ByteBuffer):MatchHeader {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param MatchHeader= obj
 * @returns MatchHeader
 */
static getRootAsMatchHeader(bb:flatbuffers.ByteBuffer, obj?:MatchHeader):MatchHeader {
  return (obj || new MatchHeader).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param MatchHeader= obj
 * @returns MatchHeader
 */
static getSizePrefixedRootAsMatchHeader(bb:flatbuffers.ByteBuffer, obj?:MatchHeader):MatchHeader {
  return (obj || new MatchHeader).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * The map the match was played on.
 *
 * @param battlecode.schema.GameMap= obj
 * @returns battlecode.schema.GameMap|null
 */
map(obj?:battlecode.schema.GameMap):battlecode.schema.GameMap|null {
  var offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? (obj || new battlecode.schema.GameMap).__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!) : null;
};

/**
 * The maximum number of rounds in this match.
 *
 * @returns number
 */
maxRounds():number {
  var offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
};

/**
 * @param flatbuffers.Builder builder
 */
static startMatchHeader(builder:flatbuffers.Builder) {
  builder.startObject(2);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset mapOffset
 */
static addMap(builder:flatbuffers.Builder, mapOffset:flatbuffers.Offset) {
  builder.addFieldOffset(0, mapOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param number maxRounds
 */
static addMaxRounds(builder:flatbuffers.Builder, maxRounds:number) {
  builder.addFieldInt32(1, maxRounds, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @returns flatbuffers.Offset
 */
static endMatchHeader(builder:flatbuffers.Builder):flatbuffers.Offset {
  var offset = builder.endObject();
  return offset;
};

static createMatchHeader(builder:flatbuffers.Builder, mapOffset:flatbuffers.Offset, maxRounds:number):flatbuffers.Offset {
  MatchHeader.startMatchHeader(builder);
  MatchHeader.addMap(builder, mapOffset);
  MatchHeader.addMaxRounds(builder, maxRounds);
  return MatchHeader.endMatchHeader(builder);
}
}
}
/**
 * Sent to end a match.
 *
 * @constructor
 */
export namespace battlecode.schema{
export class MatchFooter {
  bb: flatbuffers.ByteBuffer|null = null;

  bb_pos:number = 0;
/**
 * @param number i
 * @param flatbuffers.ByteBuffer bb
 * @returns MatchFooter
 */
__init(i:number, bb:flatbuffers.ByteBuffer):MatchFooter {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param MatchFooter= obj
 * @returns MatchFooter
 */
static getRootAsMatchFooter(bb:flatbuffers.ByteBuffer, obj?:MatchFooter):MatchFooter {
  return (obj || new MatchFooter).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param MatchFooter= obj
 * @returns MatchFooter
 */
static getSizePrefixedRootAsMatchFooter(bb:flatbuffers.ByteBuffer, obj?:MatchFooter):MatchFooter {
  return (obj || new MatchFooter).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * The ID of the winning team.
 *
 * @returns number
 */
winner():number {
  var offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.readInt8(this.bb_pos + offset) : 0;
};

/**
 * The number of rounds played.
 *
 * @returns number
 */
totalRounds():number {
  var offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
};

/**
 * @param flatbuffers.Builder builder
 */
static startMatchFooter(builder:flatbuffers.Builder) {
  builder.startObject(2);
};

/**
 * @param flatbuffers.Builder builder
 * @param number winner
 */
static addWinner(builder:flatbuffers.Builder, winner:number) {
  builder.addFieldInt8(0, winner, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param number totalRounds
 */
static addTotalRounds(builder:flatbuffers.Builder, totalRounds:number) {
  builder.addFieldInt32(1, totalRounds, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @returns flatbuffers.Offset
 */
static endMatchFooter(builder:flatbuffers.Builder):flatbuffers.Offset {
  var offset = builder.endObject();
  return offset;
};

static createMatchFooter(builder:flatbuffers.Builder, winner:number, totalRounds:number):flatbuffers.Offset {
  MatchFooter.startMatchFooter(builder);
  MatchFooter.addWinner(builder, winner);
  MatchFooter.addTotalRounds(builder, totalRounds);
  return MatchFooter.endMatchFooter(builder);
}
}
}
/**
 * A single time-step in a Game.
 * The bulk of the data in the file is stored in tables like this.
 * Note that a struct-of-arrays format is more space efficient than an array-
 * of-structs.
 *
 * @constructor
 */
export namespace battlecode.schema{
export class Round {
  bb: flatbuffers.ByteBuffer|null = null;

  bb_pos:number = 0;
/**
 * @param number i
 * @param flatbuffers.ByteBuffer bb
 * @returns Round
 */
__init(i:number, bb:flatbuffers.ByteBuffer):Round {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param Round= obj
 * @returns Round
 */
static getRootAsRound(bb:flatbuffers.ByteBuffer, obj?:Round):Round {
  return (obj || new Round).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param Round= obj
 * @returns Round
 */
static getSizePrefixedRootAsRound(bb:flatbuffers.ByteBuffer, obj?:Round):Round {
  return (obj || new Round).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * The IDs of teams in the Game.
 *
 * @param number index
 * @returns number
 */
teamIDs(index: number):number|null {
  var offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.readInt32(this.bb!.__vector(this.bb_pos + offset) + index * 4) : 0;
};

/**
 * @returns number
 */
teamIDsLength():number {
  var offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
};

/**
 * @returns Int32Array
 */
teamIDsArray():Int32Array|null {
  var offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? new Int32Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
};

/**
 * The refined soup counts of the teams.
 *
 * @param number index
 * @returns number
 */
teamSoups(index: number):number|null {
  var offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.readInt32(this.bb!.__vector(this.bb_pos + offset) + index * 4) : 0;
};

/**
 * @returns number
 */
teamSoupsLength():number {
  var offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
};

/**
 * @returns Int32Array
 */
teamSoupsArray():Int32Array|null {
  var offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? new Int32Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
};

/**
 * The IDs of bodies that moved.
 *
 * @param number index
 * @returns number
 */
movedIDs(index: number):number|null {
  var offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? this.bb!.readInt32(this.bb!.__vector(this.bb_pos + offset) + index * 4) : 0;
};

/**
 * @returns number
 */
movedIDsLength():number {
  var offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
};

/**
 * @returns Int32Array
 */
movedIDsArray():Int32Array|null {
  var offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? new Int32Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
};

/**
 * The new locations of bodies that have moved.
 *
 * @param battlecode.schema.VecTable= obj
 * @returns battlecode.schema.VecTable|null
 */
movedLocs(obj?:battlecode.schema.VecTable):battlecode.schema.VecTable|null {
  var offset = this.bb!.__offset(this.bb_pos, 10);
  return offset ? (obj || new battlecode.schema.VecTable).__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!) : null;
};

/**
 * New bodies.
 *
 * @param battlecode.schema.SpawnedBodyTable= obj
 * @returns battlecode.schema.SpawnedBodyTable|null
 */
spawnedBodies(obj?:battlecode.schema.SpawnedBodyTable):battlecode.schema.SpawnedBodyTable|null {
  var offset = this.bb!.__offset(this.bb_pos, 12);
  return offset ? (obj || new battlecode.schema.SpawnedBodyTable).__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!) : null;
};

/**
 * The IDs of bodies that died (drowned units and shot drones).
 *
 * @param number index
 * @returns number
 */
diedIDs(index: number):number|null {
  var offset = this.bb!.__offset(this.bb_pos, 14);
  return offset ? this.bb!.readInt32(this.bb!.__vector(this.bb_pos + offset) + index * 4) : 0;
};

/**
 * @returns number
 */
diedIDsLength():number {
  var offset = this.bb!.__offset(this.bb_pos, 14);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
};

/**
 * @returns Int32Array
 */
diedIDsArray():Int32Array|null {
  var offset = this.bb!.__offset(this.bb_pos, 14);
  return offset ? new Int32Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
};

/**
 * The IDs of robots that performed actions.
 * IDs may repeat.
 *
 * @param number index
 * @returns number
 */
actionIDs(index: number):number|null {
  var offset = this.bb!.__offset(this.bb_pos, 16);
  return offset ? this.bb!.readInt32(this.bb!.__vector(this.bb_pos + offset) + index * 4) : 0;
};

/**
 * @returns number
 */
actionIDsLength():number {
  var offset = this.bb!.__offset(this.bb_pos, 16);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
};

/**
 * @returns Int32Array
 */
actionIDsArray():Int32Array|null {
  var offset = this.bb!.__offset(this.bb_pos, 16);
  return offset ? new Int32Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
};

/**
 * The actions performed. These actions allow us to track how much soup or dirt a body carries.
 *
 * @param number index
 * @returns battlecode.schema.Action
 */
actions(index: number):battlecode.schema.Action|null {
  var offset = this.bb!.__offset(this.bb_pos, 18);
  return offset ? /**  */ (this.bb!.readInt8(this.bb!.__vector(this.bb_pos + offset) + index)) : /**  */ (0);
};

/**
 * @returns number
 */
actionsLength():number {
  var offset = this.bb!.__offset(this.bb_pos, 18);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
};

/**
 * @returns Int8Array
 */
actionsArray():Int8Array|null {
  var offset = this.bb!.__offset(this.bb_pos, 18);
  return offset ? new Int8Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
};

/**
 * The 'targets' of the performed actions. Actions without targets may have
 * any target (typically 0).
 *
 * @param number index
 * @returns number
 */
actionTargets(index: number):number|null {
  var offset = this.bb!.__offset(this.bb_pos, 20);
  return offset ? this.bb!.readInt32(this.bb!.__vector(this.bb_pos + offset) + index * 4) : 0;
};

/**
 * @returns number
 */
actionTargetsLength():number {
  var offset = this.bb!.__offset(this.bb_pos, 20);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
};

/**
 * @returns Int32Array
 */
actionTargetsArray():Int32Array|null {
  var offset = this.bb!.__offset(this.bb_pos, 20);
  return offset ? new Int32Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
};

/**
 * The indexes of the locations whose dirt amount changed.
 *
 * @param battlecode.schema.VecTable= obj
 * @returns battlecode.schema.VecTable|null
 */
dirtChangedLocs(obj?:battlecode.schema.VecTable):battlecode.schema.VecTable|null {
  var offset = this.bb!.__offset(this.bb_pos, 22);
  return offset ? (obj || new battlecode.schema.VecTable).__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!) : null;
};

/**
 * The amount the dirt changed by.
 *
 * @param number index
 * @returns number
 */
dirtChanges(index: number):number|null {
  var offset = this.bb!.__offset(this.bb_pos, 24);
  return offset ? this.bb!.readInt32(this.bb!.__vector(this.bb_pos + offset) + index * 4) : 0;
};

/**
 * @returns number
 */
dirtChangesLength():number {
  var offset = this.bb!.__offset(this.bb_pos, 24);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
};

/**
 * @returns Int32Array
 */
dirtChangesArray():Int32Array|null {
  var offset = this.bb!.__offset(this.bb_pos, 24);
  return offset ? new Int32Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
};

/**
 * The indexes of the locations whose flood situation changed.
 *
 * @param battlecode.schema.VecTable= obj
 * @returns battlecode.schema.VecTable|null
 */
waterChangedLocs(obj?:battlecode.schema.VecTable):battlecode.schema.VecTable|null {
  var offset = this.bb!.__offset(this.bb_pos, 26);
  return offset ? (obj || new battlecode.schema.VecTable).__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!) : null;
};

/**
 * The global pollution level
 *
 * @returns number
 */
globalPollution():number {
  var offset = this.bb!.__offset(this.bb_pos, 28);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
};

/**
 * The local pollution infos
 *
 * @param battlecode.schema.LocalPollutionTable= obj
 * @returns battlecode.schema.LocalPollutionTable|null
 */
localPollutions(obj?:battlecode.schema.LocalPollutionTable):battlecode.schema.LocalPollutionTable|null {
  var offset = this.bb!.__offset(this.bb_pos, 30);
  return offset ? (obj || new battlecode.schema.LocalPollutionTable).__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!) : null;
};

/**
 * The indexes of the locations whose soup amount changed.
 *
 * @param battlecode.schema.VecTable= obj
 * @returns battlecode.schema.VecTable|null
 */
soupChangedLocs(obj?:battlecode.schema.VecTable):battlecode.schema.VecTable|null {
  var offset = this.bb!.__offset(this.bb_pos, 32);
  return offset ? (obj || new battlecode.schema.VecTable).__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!) : null;
};

/**
 * The amount the soup changed by.
 *
 * @param number index
 * @returns number
 */
soupChanges(index: number):number|null {
  var offset = this.bb!.__offset(this.bb_pos, 34);
  return offset ? this.bb!.readInt32(this.bb!.__vector(this.bb_pos + offset) + index * 4) : 0;
};

/**
 * @returns number
 */
soupChangesLength():number {
  var offset = this.bb!.__offset(this.bb_pos, 34);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
};

/**
 * @returns Int32Array
 */
soupChangesArray():Int32Array|null {
  var offset = this.bb!.__offset(this.bb_pos, 34);
  return offset ? new Int32Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
};

/**
 * Costs of new message requests.
 *
 * @param number index
 * @returns number
 */
newMessagesCosts(index: number):number|null {
  var offset = this.bb!.__offset(this.bb_pos, 36);
  return offset ? this.bb!.readInt32(this.bb!.__vector(this.bb_pos + offset) + index * 4) : 0;
};

/**
 * @returns number
 */
newMessagesCostsLength():number {
  var offset = this.bb!.__offset(this.bb_pos, 36);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
};

/**
 * @returns Int32Array
 */
newMessagesCostsArray():Int32Array|null {
  var offset = this.bb!.__offset(this.bb_pos, 36);
  return offset ? new Int32Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
};

/**
 * New message requests.
 *
 * @param number index
 * @param flatbuffers.Encoding= optionalEncoding
 * @returns string|Uint8Array
 */
newMessages(index: number):string
newMessages(index: number,optionalEncoding:flatbuffers.Encoding):string|Uint8Array
newMessages(index: number,optionalEncoding?:any):string|Uint8Array|null {
  var offset = this.bb!.__offset(this.bb_pos, 38);
  return offset ? this.bb!.__string(this.bb!.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
};

/**
 * @returns number
 */
newMessagesLength():number {
  var offset = this.bb!.__offset(this.bb_pos, 38);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
};

/**
 * Costs of broadcasted messages.
 *
 * @param number index
 * @returns number
 */
broadcastedMessagesCosts(index: number):number|null {
  var offset = this.bb!.__offset(this.bb_pos, 40);
  return offset ? this.bb!.readInt32(this.bb!.__vector(this.bb_pos + offset) + index * 4) : 0;
};

/**
 * @returns number
 */
broadcastedMessagesCostsLength():number {
  var offset = this.bb!.__offset(this.bb_pos, 40);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
};

/**
 * @returns Int32Array
 */
broadcastedMessagesCostsArray():Int32Array|null {
  var offset = this.bb!.__offset(this.bb_pos, 40);
  return offset ? new Int32Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
};

/**
 * Broadcasted messages.
 *
 * @param number index
 * @param flatbuffers.Encoding= optionalEncoding
 * @returns string|Uint8Array
 */
broadcastedMessages(index: number):string
broadcastedMessages(index: number,optionalEncoding:flatbuffers.Encoding):string|Uint8Array
broadcastedMessages(index: number,optionalEncoding?:any):string|Uint8Array|null {
  var offset = this.bb!.__offset(this.bb_pos, 42);
  return offset ? this.bb!.__string(this.bb!.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
};

/**
 * @returns number
 */
broadcastedMessagesLength():number {
  var offset = this.bb!.__offset(this.bb_pos, 42);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
};

/**
 * The IDs of bodies that set indicator dots
 *
 * @param number index
 * @returns number
 */
indicatorDotIDs(index: number):number|null {
  var offset = this.bb!.__offset(this.bb_pos, 44);
  return offset ? this.bb!.readInt32(this.bb!.__vector(this.bb_pos + offset) + index * 4) : 0;
};

/**
 * @returns number
 */
indicatorDotIDsLength():number {
  var offset = this.bb!.__offset(this.bb_pos, 44);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
};

/**
 * @returns Int32Array
 */
indicatorDotIDsArray():Int32Array|null {
  var offset = this.bb!.__offset(this.bb_pos, 44);
  return offset ? new Int32Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
};

/**
 * The location of the indicator dots
 *
 * @param battlecode.schema.VecTable= obj
 * @returns battlecode.schema.VecTable|null
 */
indicatorDotLocs(obj?:battlecode.schema.VecTable):battlecode.schema.VecTable|null {
  var offset = this.bb!.__offset(this.bb_pos, 46);
  return offset ? (obj || new battlecode.schema.VecTable).__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!) : null;
};

/**
 * The RGB values of the indicator dots
 *
 * @param battlecode.schema.RGBTable= obj
 * @returns battlecode.schema.RGBTable|null
 */
indicatorDotRGBs(obj?:battlecode.schema.RGBTable):battlecode.schema.RGBTable|null {
  var offset = this.bb!.__offset(this.bb_pos, 48);
  return offset ? (obj || new battlecode.schema.RGBTable).__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!) : null;
};

/**
 * The IDs of bodies that set indicator lines
 *
 * @param number index
 * @returns number
 */
indicatorLineIDs(index: number):number|null {
  var offset = this.bb!.__offset(this.bb_pos, 50);
  return offset ? this.bb!.readInt32(this.bb!.__vector(this.bb_pos + offset) + index * 4) : 0;
};

/**
 * @returns number
 */
indicatorLineIDsLength():number {
  var offset = this.bb!.__offset(this.bb_pos, 50);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
};

/**
 * @returns Int32Array
 */
indicatorLineIDsArray():Int32Array|null {
  var offset = this.bb!.__offset(this.bb_pos, 50);
  return offset ? new Int32Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
};

/**
 * The start location of the indicator lines
 *
 * @param battlecode.schema.VecTable= obj
 * @returns battlecode.schema.VecTable|null
 */
indicatorLineStartLocs(obj?:battlecode.schema.VecTable):battlecode.schema.VecTable|null {
  var offset = this.bb!.__offset(this.bb_pos, 52);
  return offset ? (obj || new battlecode.schema.VecTable).__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!) : null;
};

/**
 * The end location of the indicator lines
 *
 * @param battlecode.schema.VecTable= obj
 * @returns battlecode.schema.VecTable|null
 */
indicatorLineEndLocs(obj?:battlecode.schema.VecTable):battlecode.schema.VecTable|null {
  var offset = this.bb!.__offset(this.bb_pos, 54);
  return offset ? (obj || new battlecode.schema.VecTable).__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!) : null;
};

/**
 * The RGB values of the indicator lines
 *
 * @param battlecode.schema.RGBTable= obj
 * @returns battlecode.schema.RGBTable|null
 */
indicatorLineRGBs(obj?:battlecode.schema.RGBTable):battlecode.schema.RGBTable|null {
  var offset = this.bb!.__offset(this.bb_pos, 56);
  return offset ? (obj || new battlecode.schema.RGBTable).__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!) : null;
};

/**
 * All logs sent this round.
 * Messages from a particular robot in this round start on a new line, and
 * have a header:
 * '[' $TEAM ':' $ROBOTTYPE '#' $ID '@' $ROUND '] '
 * $TEAM = 'A' | 'B'
 * $ROBOTTYPE = 'HQ' | 'VAPORATOR' | 'LANDSCAPER' 
 *            | 'DELIVERY_DRONE' | 'REFINERY' | 'MINER' | other names...
 * $ID = a number
 * $ROUND = a number
 * The header is not necessarily followed by a newline.
 * This header should only be sent once per robot per round (although
 * players may forge it, so don't crash if you get strange input.)
 *
 * You should try to only read this value once, and cache it. Reading
 * strings from a flatbuffer is much less efficient than reading other
 * buffers, because they need to be copied into an environment-provided
 * buffer and validated.
 *
 * (haha i guess you can never really escape string parsing can you)
 *
 * @param flatbuffers.Encoding= optionalEncoding
 * @returns string|Uint8Array|null
 */
logs():string|null
logs(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
logs(optionalEncoding?:any):string|Uint8Array|null {
  var offset = this.bb!.__offset(this.bb_pos, 58);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
};

/**
 * The first sent Round in a match should have index 1. (The starting state,
 * created by the MatchHeader, can be thought to have index 0.)
 * It should increase by one for each following round.
 *
 * @returns number
 */
roundID():number {
  var offset = this.bb!.__offset(this.bb_pos, 60);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
};

/**
 * The IDs of player bodies.
 *
 * @param number index
 * @returns number
 */
bytecodeIDs(index: number):number|null {
  var offset = this.bb!.__offset(this.bb_pos, 62);
  return offset ? this.bb!.readInt32(this.bb!.__vector(this.bb_pos + offset) + index * 4) : 0;
};

/**
 * @returns number
 */
bytecodeIDsLength():number {
  var offset = this.bb!.__offset(this.bb_pos, 62);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
};

/**
 * @returns Int32Array
 */
bytecodeIDsArray():Int32Array|null {
  var offset = this.bb!.__offset(this.bb_pos, 62);
  return offset ? new Int32Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
};

/**
 * The bytecodes used by the player bodies.
 *
 * @param number index
 * @returns number
 */
bytecodesUsed(index: number):number|null {
  var offset = this.bb!.__offset(this.bb_pos, 64);
  return offset ? this.bb!.readInt32(this.bb!.__vector(this.bb_pos + offset) + index * 4) : 0;
};

/**
 * @returns number
 */
bytecodesUsedLength():number {
  var offset = this.bb!.__offset(this.bb_pos, 64);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
};

/**
 * @returns Int32Array
 */
bytecodesUsedArray():Int32Array|null {
  var offset = this.bb!.__offset(this.bb_pos, 64);
  return offset ? new Int32Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
};

/**
 * @param flatbuffers.Builder builder
 */
static startRound(builder:flatbuffers.Builder) {
  builder.startObject(31);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset teamIDsOffset
 */
static addTeamIDs(builder:flatbuffers.Builder, teamIDsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(0, teamIDsOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param Array.<number> data
 * @returns flatbuffers.Offset
 */
static createTeamIDsVector(builder:flatbuffers.Builder, data:number[] | Uint8Array):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addInt32(data[i]);
  }
  return builder.endVector();
};

/**
 * @param flatbuffers.Builder builder
 * @param number numElems
 */
static startTeamIDsVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset teamSoupsOffset
 */
static addTeamSoups(builder:flatbuffers.Builder, teamSoupsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(1, teamSoupsOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param Array.<number> data
 * @returns flatbuffers.Offset
 */
static createTeamSoupsVector(builder:flatbuffers.Builder, data:number[] | Uint8Array):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addInt32(data[i]);
  }
  return builder.endVector();
};

/**
 * @param flatbuffers.Builder builder
 * @param number numElems
 */
static startTeamSoupsVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset movedIDsOffset
 */
static addMovedIDs(builder:flatbuffers.Builder, movedIDsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(2, movedIDsOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param Array.<number> data
 * @returns flatbuffers.Offset
 */
static createMovedIDsVector(builder:flatbuffers.Builder, data:number[] | Uint8Array):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addInt32(data[i]);
  }
  return builder.endVector();
};

/**
 * @param flatbuffers.Builder builder
 * @param number numElems
 */
static startMovedIDsVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset movedLocsOffset
 */
static addMovedLocs(builder:flatbuffers.Builder, movedLocsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(3, movedLocsOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset spawnedBodiesOffset
 */
static addSpawnedBodies(builder:flatbuffers.Builder, spawnedBodiesOffset:flatbuffers.Offset) {
  builder.addFieldOffset(4, spawnedBodiesOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset diedIDsOffset
 */
static addDiedIDs(builder:flatbuffers.Builder, diedIDsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(5, diedIDsOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param Array.<number> data
 * @returns flatbuffers.Offset
 */
static createDiedIDsVector(builder:flatbuffers.Builder, data:number[] | Uint8Array):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addInt32(data[i]);
  }
  return builder.endVector();
};

/**
 * @param flatbuffers.Builder builder
 * @param number numElems
 */
static startDiedIDsVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset actionIDsOffset
 */
static addActionIDs(builder:flatbuffers.Builder, actionIDsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(6, actionIDsOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param Array.<number> data
 * @returns flatbuffers.Offset
 */
static createActionIDsVector(builder:flatbuffers.Builder, data:number[] | Uint8Array):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addInt32(data[i]);
  }
  return builder.endVector();
};

/**
 * @param flatbuffers.Builder builder
 * @param number numElems
 */
static startActionIDsVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset actionsOffset
 */
static addActions(builder:flatbuffers.Builder, actionsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(7, actionsOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param Array.<battlecode.schema.Action> data
 * @returns flatbuffers.Offset
 */
static createActionsVector(builder:flatbuffers.Builder, data:battlecode.schema.Action[]):flatbuffers.Offset {
  builder.startVector(1, data.length, 1);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addInt8(data[i]);
  }
  return builder.endVector();
};

/**
 * @param flatbuffers.Builder builder
 * @param number numElems
 */
static startActionsVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(1, numElems, 1);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset actionTargetsOffset
 */
static addActionTargets(builder:flatbuffers.Builder, actionTargetsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(8, actionTargetsOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param Array.<number> data
 * @returns flatbuffers.Offset
 */
static createActionTargetsVector(builder:flatbuffers.Builder, data:number[] | Uint8Array):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addInt32(data[i]);
  }
  return builder.endVector();
};

/**
 * @param flatbuffers.Builder builder
 * @param number numElems
 */
static startActionTargetsVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset dirtChangedLocsOffset
 */
static addDirtChangedLocs(builder:flatbuffers.Builder, dirtChangedLocsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(9, dirtChangedLocsOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset dirtChangesOffset
 */
static addDirtChanges(builder:flatbuffers.Builder, dirtChangesOffset:flatbuffers.Offset) {
  builder.addFieldOffset(10, dirtChangesOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param Array.<number> data
 * @returns flatbuffers.Offset
 */
static createDirtChangesVector(builder:flatbuffers.Builder, data:number[] | Uint8Array):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addInt32(data[i]);
  }
  return builder.endVector();
};

/**
 * @param flatbuffers.Builder builder
 * @param number numElems
 */
static startDirtChangesVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset waterChangedLocsOffset
 */
static addWaterChangedLocs(builder:flatbuffers.Builder, waterChangedLocsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(11, waterChangedLocsOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param number globalPollution
 */
static addGlobalPollution(builder:flatbuffers.Builder, globalPollution:number) {
  builder.addFieldInt32(12, globalPollution, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset localPollutionsOffset
 */
static addLocalPollutions(builder:flatbuffers.Builder, localPollutionsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(13, localPollutionsOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset soupChangedLocsOffset
 */
static addSoupChangedLocs(builder:flatbuffers.Builder, soupChangedLocsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(14, soupChangedLocsOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset soupChangesOffset
 */
static addSoupChanges(builder:flatbuffers.Builder, soupChangesOffset:flatbuffers.Offset) {
  builder.addFieldOffset(15, soupChangesOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param Array.<number> data
 * @returns flatbuffers.Offset
 */
static createSoupChangesVector(builder:flatbuffers.Builder, data:number[] | Uint8Array):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addInt32(data[i]);
  }
  return builder.endVector();
};

/**
 * @param flatbuffers.Builder builder
 * @param number numElems
 */
static startSoupChangesVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset newMessagesCostsOffset
 */
static addNewMessagesCosts(builder:flatbuffers.Builder, newMessagesCostsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(16, newMessagesCostsOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param Array.<number> data
 * @returns flatbuffers.Offset
 */
static createNewMessagesCostsVector(builder:flatbuffers.Builder, data:number[] | Uint8Array):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addInt32(data[i]);
  }
  return builder.endVector();
};

/**
 * @param flatbuffers.Builder builder
 * @param number numElems
 */
static startNewMessagesCostsVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset newMessagesOffset
 */
static addNewMessages(builder:flatbuffers.Builder, newMessagesOffset:flatbuffers.Offset) {
  builder.addFieldOffset(17, newMessagesOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param Array.<flatbuffers.Offset> data
 * @returns flatbuffers.Offset
 */
static createNewMessagesVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]);
  }
  return builder.endVector();
};

/**
 * @param flatbuffers.Builder builder
 * @param number numElems
 */
static startNewMessagesVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset broadcastedMessagesCostsOffset
 */
static addBroadcastedMessagesCosts(builder:flatbuffers.Builder, broadcastedMessagesCostsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(18, broadcastedMessagesCostsOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param Array.<number> data
 * @returns flatbuffers.Offset
 */
static createBroadcastedMessagesCostsVector(builder:flatbuffers.Builder, data:number[] | Uint8Array):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addInt32(data[i]);
  }
  return builder.endVector();
};

/**
 * @param flatbuffers.Builder builder
 * @param number numElems
 */
static startBroadcastedMessagesCostsVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset broadcastedMessagesOffset
 */
static addBroadcastedMessages(builder:flatbuffers.Builder, broadcastedMessagesOffset:flatbuffers.Offset) {
  builder.addFieldOffset(19, broadcastedMessagesOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param Array.<flatbuffers.Offset> data
 * @returns flatbuffers.Offset
 */
static createBroadcastedMessagesVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]);
  }
  return builder.endVector();
};

/**
 * @param flatbuffers.Builder builder
 * @param number numElems
 */
static startBroadcastedMessagesVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset indicatorDotIDsOffset
 */
static addIndicatorDotIDs(builder:flatbuffers.Builder, indicatorDotIDsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(20, indicatorDotIDsOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param Array.<number> data
 * @returns flatbuffers.Offset
 */
static createIndicatorDotIDsVector(builder:flatbuffers.Builder, data:number[] | Uint8Array):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addInt32(data[i]);
  }
  return builder.endVector();
};

/**
 * @param flatbuffers.Builder builder
 * @param number numElems
 */
static startIndicatorDotIDsVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset indicatorDotLocsOffset
 */
static addIndicatorDotLocs(builder:flatbuffers.Builder, indicatorDotLocsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(21, indicatorDotLocsOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset indicatorDotRGBsOffset
 */
static addIndicatorDotRGBs(builder:flatbuffers.Builder, indicatorDotRGBsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(22, indicatorDotRGBsOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset indicatorLineIDsOffset
 */
static addIndicatorLineIDs(builder:flatbuffers.Builder, indicatorLineIDsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(23, indicatorLineIDsOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param Array.<number> data
 * @returns flatbuffers.Offset
 */
static createIndicatorLineIDsVector(builder:flatbuffers.Builder, data:number[] | Uint8Array):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addInt32(data[i]);
  }
  return builder.endVector();
};

/**
 * @param flatbuffers.Builder builder
 * @param number numElems
 */
static startIndicatorLineIDsVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset indicatorLineStartLocsOffset
 */
static addIndicatorLineStartLocs(builder:flatbuffers.Builder, indicatorLineStartLocsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(24, indicatorLineStartLocsOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset indicatorLineEndLocsOffset
 */
static addIndicatorLineEndLocs(builder:flatbuffers.Builder, indicatorLineEndLocsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(25, indicatorLineEndLocsOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset indicatorLineRGBsOffset
 */
static addIndicatorLineRGBs(builder:flatbuffers.Builder, indicatorLineRGBsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(26, indicatorLineRGBsOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset logsOffset
 */
static addLogs(builder:flatbuffers.Builder, logsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(27, logsOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param number roundID
 */
static addRoundID(builder:flatbuffers.Builder, roundID:number) {
  builder.addFieldInt32(28, roundID, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset bytecodeIDsOffset
 */
static addBytecodeIDs(builder:flatbuffers.Builder, bytecodeIDsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(29, bytecodeIDsOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param Array.<number> data
 * @returns flatbuffers.Offset
 */
static createBytecodeIDsVector(builder:flatbuffers.Builder, data:number[] | Uint8Array):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addInt32(data[i]);
  }
  return builder.endVector();
};

/**
 * @param flatbuffers.Builder builder
 * @param number numElems
 */
static startBytecodeIDsVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset bytecodesUsedOffset
 */
static addBytecodesUsed(builder:flatbuffers.Builder, bytecodesUsedOffset:flatbuffers.Offset) {
  builder.addFieldOffset(30, bytecodesUsedOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param Array.<number> data
 * @returns flatbuffers.Offset
 */
static createBytecodesUsedVector(builder:flatbuffers.Builder, data:number[] | Uint8Array):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addInt32(data[i]);
  }
  return builder.endVector();
};

/**
 * @param flatbuffers.Builder builder
 * @param number numElems
 */
static startBytecodesUsedVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
};

/**
 * @param flatbuffers.Builder builder
 * @returns flatbuffers.Offset
 */
static endRound(builder:flatbuffers.Builder):flatbuffers.Offset {
  var offset = builder.endObject();
  return offset;
};

static createRound(builder:flatbuffers.Builder, teamIDsOffset:flatbuffers.Offset, teamSoupsOffset:flatbuffers.Offset, movedIDsOffset:flatbuffers.Offset, movedLocsOffset:flatbuffers.Offset, spawnedBodiesOffset:flatbuffers.Offset, diedIDsOffset:flatbuffers.Offset, actionIDsOffset:flatbuffers.Offset, actionsOffset:flatbuffers.Offset, actionTargetsOffset:flatbuffers.Offset, dirtChangedLocsOffset:flatbuffers.Offset, dirtChangesOffset:flatbuffers.Offset, waterChangedLocsOffset:flatbuffers.Offset, globalPollution:number, localPollutionsOffset:flatbuffers.Offset, soupChangedLocsOffset:flatbuffers.Offset, soupChangesOffset:flatbuffers.Offset, newMessagesCostsOffset:flatbuffers.Offset, newMessagesOffset:flatbuffers.Offset, broadcastedMessagesCostsOffset:flatbuffers.Offset, broadcastedMessagesOffset:flatbuffers.Offset, indicatorDotIDsOffset:flatbuffers.Offset, indicatorDotLocsOffset:flatbuffers.Offset, indicatorDotRGBsOffset:flatbuffers.Offset, indicatorLineIDsOffset:flatbuffers.Offset, indicatorLineStartLocsOffset:flatbuffers.Offset, indicatorLineEndLocsOffset:flatbuffers.Offset, indicatorLineRGBsOffset:flatbuffers.Offset, logsOffset:flatbuffers.Offset, roundID:number, bytecodeIDsOffset:flatbuffers.Offset, bytecodesUsedOffset:flatbuffers.Offset):flatbuffers.Offset {
  Round.startRound(builder);
  Round.addTeamIDs(builder, teamIDsOffset);
  Round.addTeamSoups(builder, teamSoupsOffset);
  Round.addMovedIDs(builder, movedIDsOffset);
  Round.addMovedLocs(builder, movedLocsOffset);
  Round.addSpawnedBodies(builder, spawnedBodiesOffset);
  Round.addDiedIDs(builder, diedIDsOffset);
  Round.addActionIDs(builder, actionIDsOffset);
  Round.addActions(builder, actionsOffset);
  Round.addActionTargets(builder, actionTargetsOffset);
  Round.addDirtChangedLocs(builder, dirtChangedLocsOffset);
  Round.addDirtChanges(builder, dirtChangesOffset);
  Round.addWaterChangedLocs(builder, waterChangedLocsOffset);
  Round.addGlobalPollution(builder, globalPollution);
  Round.addLocalPollutions(builder, localPollutionsOffset);
  Round.addSoupChangedLocs(builder, soupChangedLocsOffset);
  Round.addSoupChanges(builder, soupChangesOffset);
  Round.addNewMessagesCosts(builder, newMessagesCostsOffset);
  Round.addNewMessages(builder, newMessagesOffset);
  Round.addBroadcastedMessagesCosts(builder, broadcastedMessagesCostsOffset);
  Round.addBroadcastedMessages(builder, broadcastedMessagesOffset);
  Round.addIndicatorDotIDs(builder, indicatorDotIDsOffset);
  Round.addIndicatorDotLocs(builder, indicatorDotLocsOffset);
  Round.addIndicatorDotRGBs(builder, indicatorDotRGBsOffset);
  Round.addIndicatorLineIDs(builder, indicatorLineIDsOffset);
  Round.addIndicatorLineStartLocs(builder, indicatorLineStartLocsOffset);
  Round.addIndicatorLineEndLocs(builder, indicatorLineEndLocsOffset);
  Round.addIndicatorLineRGBs(builder, indicatorLineRGBsOffset);
  Round.addLogs(builder, logsOffset);
  Round.addRoundID(builder, roundID);
  Round.addBytecodeIDs(builder, bytecodeIDsOffset);
  Round.addBytecodesUsed(builder, bytecodesUsedOffset);
  return Round.endRound(builder);
}
}
}
/**
 * Necessary due to flatbuffers requiring unions to be wrapped in tables.
 *
 * @constructor
 */
export namespace battlecode.schema{
export class EventWrapper {
  bb: flatbuffers.ByteBuffer|null = null;

  bb_pos:number = 0;
/**
 * @param number i
 * @param flatbuffers.ByteBuffer bb
 * @returns EventWrapper
 */
__init(i:number, bb:flatbuffers.ByteBuffer):EventWrapper {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param EventWrapper= obj
 * @returns EventWrapper
 */
static getRootAsEventWrapper(bb:flatbuffers.ByteBuffer, obj?:EventWrapper):EventWrapper {
  return (obj || new EventWrapper).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param EventWrapper= obj
 * @returns EventWrapper
 */
static getSizePrefixedRootAsEventWrapper(bb:flatbuffers.ByteBuffer, obj?:EventWrapper):EventWrapper {
  return (obj || new EventWrapper).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * @returns battlecode.schema.Event
 */
eType():battlecode.schema.Event {
  var offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? /**  */ (this.bb!.readUint8(this.bb_pos + offset)) : battlecode.schema.Event.NONE;
};

/**
 * @param flatbuffers.Table obj
 * @returns ?flatbuffers.Table
 */
e<T extends flatbuffers.Table>(obj:T):T|null {
  var offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.__union(obj, this.bb_pos + offset) : null;
};

/**
 * @param flatbuffers.Builder builder
 */
static startEventWrapper(builder:flatbuffers.Builder) {
  builder.startObject(2);
};

/**
 * @param flatbuffers.Builder builder
 * @param battlecode.schema.Event eType
 */
static addEType(builder:flatbuffers.Builder, eType:battlecode.schema.Event) {
  builder.addFieldInt8(0, eType, battlecode.schema.Event.NONE);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset eOffset
 */
static addE(builder:flatbuffers.Builder, eOffset:flatbuffers.Offset) {
  builder.addFieldOffset(1, eOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @returns flatbuffers.Offset
 */
static endEventWrapper(builder:flatbuffers.Builder):flatbuffers.Offset {
  var offset = builder.endObject();
  return offset;
};

static createEventWrapper(builder:flatbuffers.Builder, eType:battlecode.schema.Event, eOffset:flatbuffers.Offset):flatbuffers.Offset {
  EventWrapper.startEventWrapper(builder);
  EventWrapper.addEType(builder, eType);
  EventWrapper.addE(builder, eOffset);
  return EventWrapper.endEventWrapper(builder);
}
}
}
/**
 * If events are not otherwise delimited, this wrapper structure
 * allows a game to be stored in a single buffer.
 * The first event will be a GameHeader; the last event will be a GameFooter.
 * matchHeaders[0] is the index of the 0th match header in the event stream,
 * corresponding to matchFooters[0]. These indices allow quick traversal of
 * the file.
 *
 * @constructor
 */
export namespace battlecode.schema{
export class GameWrapper {
  bb: flatbuffers.ByteBuffer|null = null;

  bb_pos:number = 0;
/**
 * @param number i
 * @param flatbuffers.ByteBuffer bb
 * @returns GameWrapper
 */
__init(i:number, bb:flatbuffers.ByteBuffer):GameWrapper {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param GameWrapper= obj
 * @returns GameWrapper
 */
static getRootAsGameWrapper(bb:flatbuffers.ByteBuffer, obj?:GameWrapper):GameWrapper {
  return (obj || new GameWrapper).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param GameWrapper= obj
 * @returns GameWrapper
 */
static getSizePrefixedRootAsGameWrapper(bb:flatbuffers.ByteBuffer, obj?:GameWrapper):GameWrapper {
  return (obj || new GameWrapper).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * The series of events comprising the game.
 *
 * @param number index
 * @param battlecode.schema.EventWrapper= obj
 * @returns battlecode.schema.EventWrapper
 */
events(index: number, obj?:battlecode.schema.EventWrapper):battlecode.schema.EventWrapper|null {
  var offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? (obj || new battlecode.schema.EventWrapper).__init(this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4), this.bb!) : null;
};

/**
 * @returns number
 */
eventsLength():number {
  var offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
};

/**
 * The indices of the headers of the matches, in order.
 *
 * @param number index
 * @returns number
 */
matchHeaders(index: number):number|null {
  var offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.readInt32(this.bb!.__vector(this.bb_pos + offset) + index * 4) : 0;
};

/**
 * @returns number
 */
matchHeadersLength():number {
  var offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
};

/**
 * @returns Int32Array
 */
matchHeadersArray():Int32Array|null {
  var offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? new Int32Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
};

/**
 * The indices of the footers of the matches, in order.
 *
 * @param number index
 * @returns number
 */
matchFooters(index: number):number|null {
  var offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? this.bb!.readInt32(this.bb!.__vector(this.bb_pos + offset) + index * 4) : 0;
};

/**
 * @returns number
 */
matchFootersLength():number {
  var offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
};

/**
 * @returns Int32Array
 */
matchFootersArray():Int32Array|null {
  var offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? new Int32Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
};

/**
 * @param flatbuffers.Builder builder
 */
static startGameWrapper(builder:flatbuffers.Builder) {
  builder.startObject(3);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset eventsOffset
 */
static addEvents(builder:flatbuffers.Builder, eventsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(0, eventsOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param Array.<flatbuffers.Offset> data
 * @returns flatbuffers.Offset
 */
static createEventsVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]);
  }
  return builder.endVector();
};

/**
 * @param flatbuffers.Builder builder
 * @param number numElems
 */
static startEventsVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset matchHeadersOffset
 */
static addMatchHeaders(builder:flatbuffers.Builder, matchHeadersOffset:flatbuffers.Offset) {
  builder.addFieldOffset(1, matchHeadersOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param Array.<number> data
 * @returns flatbuffers.Offset
 */
static createMatchHeadersVector(builder:flatbuffers.Builder, data:number[] | Uint8Array):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addInt32(data[i]);
  }
  return builder.endVector();
};

/**
 * @param flatbuffers.Builder builder
 * @param number numElems
 */
static startMatchHeadersVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset matchFootersOffset
 */
static addMatchFooters(builder:flatbuffers.Builder, matchFootersOffset:flatbuffers.Offset) {
  builder.addFieldOffset(2, matchFootersOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param Array.<number> data
 * @returns flatbuffers.Offset
 */
static createMatchFootersVector(builder:flatbuffers.Builder, data:number[] | Uint8Array):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addInt32(data[i]);
  }
  return builder.endVector();
};

/**
 * @param flatbuffers.Builder builder
 * @param number numElems
 */
static startMatchFootersVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
};

/**
 * @param flatbuffers.Builder builder
 * @returns flatbuffers.Offset
 */
static endGameWrapper(builder:flatbuffers.Builder):flatbuffers.Offset {
  var offset = builder.endObject();
  return offset;
};

static createGameWrapper(builder:flatbuffers.Builder, eventsOffset:flatbuffers.Offset, matchHeadersOffset:flatbuffers.Offset, matchFootersOffset:flatbuffers.Offset):flatbuffers.Offset {
  GameWrapper.startGameWrapper(builder);
  GameWrapper.addEvents(builder, eventsOffset);
  GameWrapper.addMatchHeaders(builder, matchHeadersOffset);
  GameWrapper.addMatchFooters(builder, matchFootersOffset);
  return GameWrapper.endGameWrapper(builder);
}
}
}
