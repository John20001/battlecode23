// automatically generated by the FlatBuffers compiler, do not modify

import * as flatbuffers from 'flatbuffers';
/**
 * The possible types of things that can exist.
 * Note that bullets are not treated as bodies.
 *
 * @enum {number}
 */
export namespace battlecode.schema{
export enum BodyType{
  /**
   * Enlightenment centers produce politicians, scandals and muckrakers and place bets
   *can be neutral until captured
   */
  ENLIGHTENMENT_CENTER= 0,

  /**
   * politicians use their influence to self destruct and capture other units
   */
  POLITICIAN= 1,

  /**
   * scandals generate passive influence for the enlightenment center that created them
   * they turn into politicians at some point, and can only be identified by muckrakers.
   */
  SCANDAL= 2,

  /**
   * have the ability to identify scandals
   */
  MUCKRAKER= 3
};
}

/**
 * Actions that can be performed.
 * Purely aesthetic; have no actual effect on simulation.
 * (Although the simulation may want to track the 'parents' of
 * particular robots.)
 * Actions may have 'targets', which are the units on which
 * the actions were performed.
 *
 * @enum {number}
 */
export namespace battlecode.schema{
export enum Action{
  /**
   * politicians self-destruct and affect nearby bodies
   * Target: none
   */
  EMPOWER= 0,

  /**
   * scandals turn into politicians.
   * Target: self.
   */
  CAMOUFLAGE= 1,

  /**
   * slanders are alowed to TODO.
   * Target: TODO.
   */
  EMBEZZLE= 2,

  /**
   * Muckrakers can expose a scandal.
   * Target: an enemy body.
   */
  EXPOSE= 3,

  /**
   * units can change their flag.
   * Target: self.
   */
  SET_FLAG= 4,

  /**
   * units can get the flag of another unit
   * Target: another unit.
   */
  GET_FLAG= 5,

  /**
   * Builds a unit (enlightent center).
   * Target: spawned unit
   */
  SPAWN_UNIT= 6,

  /**
   * places a bet (enlightent center).
   * Target: bet placed
   */
  PLACE_BET= 7,

  /**
   * Dies by moving into a swamp.
   * Target: drowning robot.
   */
  DIE_DROWN= 8,

  /**
   * Dies for having zero influence.
   * Target: a politician, scandal or Muckrakers.
   */
  DIE_ZERO_INFLUENCE= 9,

  /**
   * a robot can change team after being empowered
   * Target: self
   */
  CHANGE_TEAM= 10,

  /**
   * an enlightenment center can become neutral if lost all its influence
   * Target: none.
   */
  BECOME_NEUTRAL= 11,

  /**
   * Dies due to an uncaught exception
   * Target: none
   */
  DIE_EXCEPTION= 12
};
}

/**
 * An Event is a single step that needs to be processed.
 * A saved game simply consists of a long list of Events.
 * Events can be divided by either being sent separately (e.g. as separate
 * websocket messages), or by being wrapped with a GameWrapper.
 * A game consists of a series of matches; a match consists of a series of
 * rounds, and is played on a single map. Each round is a single simulation
 * step.
 *
 * @enum {number}
 */
export namespace battlecode.schema{
export enum Event{
  NONE= 0,

  /**
   * There should only be one GameHeader, at the start of the stream.
   */
  GameHeader= 1,

  /**
   * There should be one MatchHeader at the start of each match.
   */
  MatchHeader= 2,

  /**
   * A single simulation step. A round may be skipped if
   * nothing happens during its time.
   */
  Round= 3,

  /**
   * There should be one MatchFooter at the end of each simulation step.
   */
  MatchFooter= 4,

  /**
   * There should only be one GameFooter, at the end of the stream.
   */
  GameFooter= 5
};

export function unionToEvent(
  type: Event,
  accessor: (obj:battlecode.schema.GameFooter|battlecode.schema.GameHeader|battlecode.schema.MatchFooter|battlecode.schema.MatchHeader|battlecode.schema.Round) => battlecode.schema.GameFooter|battlecode.schema.GameHeader|battlecode.schema.MatchFooter|battlecode.schema.MatchHeader|battlecode.schema.Round|null
): battlecode.schema.GameFooter|battlecode.schema.GameHeader|battlecode.schema.MatchFooter|battlecode.schema.MatchHeader|battlecode.schema.Round|null {
  switch(battlecode.schema.Event[type]) {
    case 'NONE': return null; 
    case 'GameHeader': return accessor(new battlecode.schema.GameHeader())! as battlecode.schema.GameHeader;
    case 'MatchHeader': return accessor(new battlecode.schema.MatchHeader())! as battlecode.schema.MatchHeader;
    case 'Round': return accessor(new battlecode.schema.Round())! as battlecode.schema.Round;
    case 'MatchFooter': return accessor(new battlecode.schema.MatchFooter())! as battlecode.schema.MatchFooter;
    case 'GameFooter': return accessor(new battlecode.schema.GameFooter())! as battlecode.schema.GameFooter;
    default: return null;
  }
}

export function unionListToEvent(
  type: Event, 
  accessor: (index: number, obj:battlecode.schema.GameFooter|battlecode.schema.GameHeader|battlecode.schema.MatchFooter|battlecode.schema.MatchHeader|battlecode.schema.Round) => battlecode.schema.GameFooter|battlecode.schema.GameHeader|battlecode.schema.MatchFooter|battlecode.schema.MatchHeader|battlecode.schema.Round|null, 
  index: number
): battlecode.schema.GameFooter|battlecode.schema.GameHeader|battlecode.schema.MatchFooter|battlecode.schema.MatchHeader|battlecode.schema.Round|null {
  switch(battlecode.schema.Event[type]) {
    case 'NONE': return null; 
    case 'GameHeader': return accessor(index, new battlecode.schema.GameHeader())! as battlecode.schema.GameHeader;
    case 'MatchHeader': return accessor(index, new battlecode.schema.MatchHeader())! as battlecode.schema.MatchHeader;
    case 'Round': return accessor(index, new battlecode.schema.Round())! as battlecode.schema.Round;
    case 'MatchFooter': return accessor(index, new battlecode.schema.MatchFooter())! as battlecode.schema.MatchFooter;
    case 'GameFooter': return accessor(index, new battlecode.schema.GameFooter())! as battlecode.schema.GameFooter;
    default: return null;
  }
}
}

/**
 * A vector in two-dimensional space. Discrete space, of course.
 * Defaults to the 0 vector.
 *
 * @constructor
 */
export namespace battlecode.schema{
export class Vec {
  bb: flatbuffers.ByteBuffer|null = null;

  bb_pos:number = 0;
/**
 * @param number i
 * @param flatbuffers.ByteBuffer bb
 * @returns Vec
 */
__init(i:number, bb:flatbuffers.ByteBuffer):Vec {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

/**
 * @returns number
 */
x():number {
  return this.bb!.readInt32(this.bb_pos);
};

/**
 * @returns number
 */
y():number {
  return this.bb!.readInt32(this.bb_pos + 4);
};

/**
 * @returns number
 */
static sizeOf():number {
  return 8;
}

/**
 * @param flatbuffers.Builder builder
 * @param number x
 * @param number y
 * @returns flatbuffers.Offset
 */
static createVec(builder:flatbuffers.Builder, x: number, y: number):flatbuffers.Offset {
  builder.prep(4, 8);
  builder.writeInt32(y);
  builder.writeInt32(x);
  return builder.offset();
};

}
}
/**
 * A table of vectors.
 *
 * @constructor
 */
export namespace battlecode.schema{
export class VecTable {
  bb: flatbuffers.ByteBuffer|null = null;

  bb_pos:number = 0;
/**
 * @param number i
 * @param flatbuffers.ByteBuffer bb
 * @returns VecTable
 */
__init(i:number, bb:flatbuffers.ByteBuffer):VecTable {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param VecTable= obj
 * @returns VecTable
 */
static getRootAsVecTable(bb:flatbuffers.ByteBuffer, obj?:VecTable):VecTable {
  return (obj || new VecTable()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param VecTable= obj
 * @returns VecTable
 */
static getSizePrefixedRootAsVecTable(bb:flatbuffers.ByteBuffer, obj?:VecTable):VecTable {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new VecTable()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * @param number index
 * @returns number
 */
xs(index: number):number|null {
  var offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.readInt32(this.bb!.__vector(this.bb_pos + offset) + index * 4) : 0;
};

/**
 * @returns number
 */
xsLength():number {
  var offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
};

/**
 * @returns Int32Array
 */
xsArray():Int32Array|null {
  var offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? new Int32Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
};

/**
 * @param number index
 * @returns number
 */
ys(index: number):number|null {
  var offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.readInt32(this.bb!.__vector(this.bb_pos + offset) + index * 4) : 0;
};

/**
 * @returns number
 */
ysLength():number {
  var offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
};

/**
 * @returns Int32Array
 */
ysArray():Int32Array|null {
  var offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? new Int32Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
};

/**
 * @param flatbuffers.Builder builder
 */
static startVecTable(builder:flatbuffers.Builder) {
  builder.startObject(2);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset xsOffset
 */
static addXs(builder:flatbuffers.Builder, xsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(0, xsOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param Array.<number> data
 * @returns flatbuffers.Offset
 */
static createXsVector(builder:flatbuffers.Builder, data:number[]|Int32Array):flatbuffers.Offset;
/**
 * @deprecated This Uint8Array overload will be removed in the future.
 */
static createXsVector(builder:flatbuffers.Builder, data:number[]|Uint8Array):flatbuffers.Offset;
static createXsVector(builder:flatbuffers.Builder, data:number[]|Int32Array|Uint8Array):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addInt32(data[i]);
  }
  return builder.endVector();
};

/**
 * @param flatbuffers.Builder builder
 * @param number numElems
 */
static startXsVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset ysOffset
 */
static addYs(builder:flatbuffers.Builder, ysOffset:flatbuffers.Offset) {
  builder.addFieldOffset(1, ysOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param Array.<number> data
 * @returns flatbuffers.Offset
 */
static createYsVector(builder:flatbuffers.Builder, data:number[]|Int32Array):flatbuffers.Offset;
/**
 * @deprecated This Uint8Array overload will be removed in the future.
 */
static createYsVector(builder:flatbuffers.Builder, data:number[]|Uint8Array):flatbuffers.Offset;
static createYsVector(builder:flatbuffers.Builder, data:number[]|Int32Array|Uint8Array):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addInt32(data[i]);
  }
  return builder.endVector();
};

/**
 * @param flatbuffers.Builder builder
 * @param number numElems
 */
static startYsVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
};

/**
 * @param flatbuffers.Builder builder
 * @returns flatbuffers.Offset
 */
static endVecTable(builder:flatbuffers.Builder):flatbuffers.Offset {
  var offset = builder.endObject();
  return offset;
};

static createVecTable(builder:flatbuffers.Builder, xsOffset:flatbuffers.Offset, ysOffset:flatbuffers.Offset):flatbuffers.Offset {
  VecTable.startVecTable(builder);
  VecTable.addXs(builder, xsOffset);
  VecTable.addYs(builder, ysOffset);
  return VecTable.endVecTable(builder);
}
}
}
/**
 * A table of RGB values.
 *
 * @constructor
 */
export namespace battlecode.schema{
export class RGBTable {
  bb: flatbuffers.ByteBuffer|null = null;

  bb_pos:number = 0;
/**
 * @param number i
 * @param flatbuffers.ByteBuffer bb
 * @returns RGBTable
 */
__init(i:number, bb:flatbuffers.ByteBuffer):RGBTable {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param RGBTable= obj
 * @returns RGBTable
 */
static getRootAsRGBTable(bb:flatbuffers.ByteBuffer, obj?:RGBTable):RGBTable {
  return (obj || new RGBTable()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param RGBTable= obj
 * @returns RGBTable
 */
static getSizePrefixedRootAsRGBTable(bb:flatbuffers.ByteBuffer, obj?:RGBTable):RGBTable {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new RGBTable()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * @param number index
 * @returns number
 */
red(index: number):number|null {
  var offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.readInt32(this.bb!.__vector(this.bb_pos + offset) + index * 4) : 0;
};

/**
 * @returns number
 */
redLength():number {
  var offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
};

/**
 * @returns Int32Array
 */
redArray():Int32Array|null {
  var offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? new Int32Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
};

/**
 * @param number index
 * @returns number
 */
green(index: number):number|null {
  var offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.readInt32(this.bb!.__vector(this.bb_pos + offset) + index * 4) : 0;
};

/**
 * @returns number
 */
greenLength():number {
  var offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
};

/**
 * @returns Int32Array
 */
greenArray():Int32Array|null {
  var offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? new Int32Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
};

/**
 * @param number index
 * @returns number
 */
blue(index: number):number|null {
  var offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? this.bb!.readInt32(this.bb!.__vector(this.bb_pos + offset) + index * 4) : 0;
};

/**
 * @returns number
 */
blueLength():number {
  var offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
};

/**
 * @returns Int32Array
 */
blueArray():Int32Array|null {
  var offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? new Int32Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
};

/**
 * @param flatbuffers.Builder builder
 */
static startRGBTable(builder:flatbuffers.Builder) {
  builder.startObject(3);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset redOffset
 */
static addRed(builder:flatbuffers.Builder, redOffset:flatbuffers.Offset) {
  builder.addFieldOffset(0, redOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param Array.<number> data
 * @returns flatbuffers.Offset
 */
static createRedVector(builder:flatbuffers.Builder, data:number[]|Int32Array):flatbuffers.Offset;
/**
 * @deprecated This Uint8Array overload will be removed in the future.
 */
static createRedVector(builder:flatbuffers.Builder, data:number[]|Uint8Array):flatbuffers.Offset;
static createRedVector(builder:flatbuffers.Builder, data:number[]|Int32Array|Uint8Array):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addInt32(data[i]);
  }
  return builder.endVector();
};

/**
 * @param flatbuffers.Builder builder
 * @param number numElems
 */
static startRedVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset greenOffset
 */
static addGreen(builder:flatbuffers.Builder, greenOffset:flatbuffers.Offset) {
  builder.addFieldOffset(1, greenOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param Array.<number> data
 * @returns flatbuffers.Offset
 */
static createGreenVector(builder:flatbuffers.Builder, data:number[]|Int32Array):flatbuffers.Offset;
/**
 * @deprecated This Uint8Array overload will be removed in the future.
 */
static createGreenVector(builder:flatbuffers.Builder, data:number[]|Uint8Array):flatbuffers.Offset;
static createGreenVector(builder:flatbuffers.Builder, data:number[]|Int32Array|Uint8Array):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addInt32(data[i]);
  }
  return builder.endVector();
};

/**
 * @param flatbuffers.Builder builder
 * @param number numElems
 */
static startGreenVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset blueOffset
 */
static addBlue(builder:flatbuffers.Builder, blueOffset:flatbuffers.Offset) {
  builder.addFieldOffset(2, blueOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param Array.<number> data
 * @returns flatbuffers.Offset
 */
static createBlueVector(builder:flatbuffers.Builder, data:number[]|Int32Array):flatbuffers.Offset;
/**
 * @deprecated This Uint8Array overload will be removed in the future.
 */
static createBlueVector(builder:flatbuffers.Builder, data:number[]|Uint8Array):flatbuffers.Offset;
static createBlueVector(builder:flatbuffers.Builder, data:number[]|Int32Array|Uint8Array):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addInt32(data[i]);
  }
  return builder.endVector();
};

/**
 * @param flatbuffers.Builder builder
 * @param number numElems
 */
static startBlueVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
};

/**
 * @param flatbuffers.Builder builder
 * @returns flatbuffers.Offset
 */
static endRGBTable(builder:flatbuffers.Builder):flatbuffers.Offset {
  var offset = builder.endObject();
  return offset;
};

static createRGBTable(builder:flatbuffers.Builder, redOffset:flatbuffers.Offset, greenOffset:flatbuffers.Offset, blueOffset:flatbuffers.Offset):flatbuffers.Offset {
  RGBTable.startRGBTable(builder);
  RGBTable.addRed(builder, redOffset);
  RGBTable.addGreen(builder, greenOffset);
  RGBTable.addBlue(builder, blueOffset);
  return RGBTable.endRGBTable(builder);
}
}
}
/**
 * A list of new bodies to be placed on the map.
 *
 * @constructor
 */
export namespace battlecode.schema{
export class SpawnedBodyTable {
  bb: flatbuffers.ByteBuffer|null = null;

  bb_pos:number = 0;
/**
 * @param number i
 * @param flatbuffers.ByteBuffer bb
 * @returns SpawnedBodyTable
 */
__init(i:number, bb:flatbuffers.ByteBuffer):SpawnedBodyTable {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param SpawnedBodyTable= obj
 * @returns SpawnedBodyTable
 */
static getRootAsSpawnedBodyTable(bb:flatbuffers.ByteBuffer, obj?:SpawnedBodyTable):SpawnedBodyTable {
  return (obj || new SpawnedBodyTable()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param SpawnedBodyTable= obj
 * @returns SpawnedBodyTable
 */
static getSizePrefixedRootAsSpawnedBodyTable(bb:flatbuffers.ByteBuffer, obj?:SpawnedBodyTable):SpawnedBodyTable {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new SpawnedBodyTable()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * The numeric ID of the new bodies.
 * Will never be negative.
 * There will only be one body with a particular ID at a time.
 * So, there will never be two robots with the same ID, or a robot and
 * a building with the same ID.
 *
 * @param number index
 * @returns number
 */
robotIDs(index: number):number|null {
  var offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.readInt32(this.bb!.__vector(this.bb_pos + offset) + index * 4) : 0;
};

/**
 * @returns number
 */
robotIDsLength():number {
  var offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
};

/**
 * @returns Int32Array
 */
robotIDsArray():Int32Array|null {
  var offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? new Int32Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
};

/**
 * The teams of the new bodies.
 *
 * @param number index
 * @returns number
 */
teamIDs(index: number):number|null {
  var offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.readInt8(this.bb!.__vector(this.bb_pos + offset) + index) : 0;
};

/**
 * @returns number
 */
teamIDsLength():number {
  var offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
};

/**
 * @returns Int8Array
 */
teamIDsArray():Int8Array|null {
  var offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? new Int8Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
};

/**
 * The types of the new bodies.
 *
 * @param number index
 * @returns battlecode.schema.BodyType
 */
types(index: number):battlecode.schema.BodyType|null {
  var offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? /**  */ (this.bb!.readInt8(this.bb!.__vector(this.bb_pos + offset) + index)) : /**  */ (0);
};

/**
 * @returns number
 */
typesLength():number {
  var offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
};

/**
 * @returns Int8Array
 */
typesArray():Int8Array|null {
  var offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? new Int8Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
};

/**
 * The locations of the bodies.
 *
 * @param battlecode.schema.VecTable= obj
 * @returns battlecode.schema.VecTable|null
 */
locs(obj?:battlecode.schema.VecTable):battlecode.schema.VecTable|null {
  var offset = this.bb!.__offset(this.bb_pos, 10);
  return offset ? (obj || new battlecode.schema.VecTable()).__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!) : null;
};

/**
 * @param flatbuffers.Builder builder
 */
static startSpawnedBodyTable(builder:flatbuffers.Builder) {
  builder.startObject(4);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset robotIDsOffset
 */
static addRobotIDs(builder:flatbuffers.Builder, robotIDsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(0, robotIDsOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param Array.<number> data
 * @returns flatbuffers.Offset
 */
static createRobotIDsVector(builder:flatbuffers.Builder, data:number[]|Int32Array):flatbuffers.Offset;
/**
 * @deprecated This Uint8Array overload will be removed in the future.
 */
static createRobotIDsVector(builder:flatbuffers.Builder, data:number[]|Uint8Array):flatbuffers.Offset;
static createRobotIDsVector(builder:flatbuffers.Builder, data:number[]|Int32Array|Uint8Array):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addInt32(data[i]);
  }
  return builder.endVector();
};

/**
 * @param flatbuffers.Builder builder
 * @param number numElems
 */
static startRobotIDsVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset teamIDsOffset
 */
static addTeamIDs(builder:flatbuffers.Builder, teamIDsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(1, teamIDsOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param Array.<number> data
 * @returns flatbuffers.Offset
 */
static createTeamIDsVector(builder:flatbuffers.Builder, data:number[]|Int8Array):flatbuffers.Offset;
/**
 * @deprecated This Uint8Array overload will be removed in the future.
 */
static createTeamIDsVector(builder:flatbuffers.Builder, data:number[]|Uint8Array):flatbuffers.Offset;
static createTeamIDsVector(builder:flatbuffers.Builder, data:number[]|Int8Array|Uint8Array):flatbuffers.Offset {
  builder.startVector(1, data.length, 1);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addInt8(data[i]);
  }
  return builder.endVector();
};

/**
 * @param flatbuffers.Builder builder
 * @param number numElems
 */
static startTeamIDsVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(1, numElems, 1);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset typesOffset
 */
static addTypes(builder:flatbuffers.Builder, typesOffset:flatbuffers.Offset) {
  builder.addFieldOffset(2, typesOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param Array.<battlecode.schema.BodyType> data
 * @returns flatbuffers.Offset
 */
static createTypesVector(builder:flatbuffers.Builder, data:battlecode.schema.BodyType[]):flatbuffers.Offset {
  builder.startVector(1, data.length, 1);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addInt8(data[i]);
  }
  return builder.endVector();
};

/**
 * @param flatbuffers.Builder builder
 * @param number numElems
 */
static startTypesVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(1, numElems, 1);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset locsOffset
 */
static addLocs(builder:flatbuffers.Builder, locsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(3, locsOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @returns flatbuffers.Offset
 */
static endSpawnedBodyTable(builder:flatbuffers.Builder):flatbuffers.Offset {
  var offset = builder.endObject();
  return offset;
};

}
}
/**
 * The map a round is played on.
 *
 * @constructor
 */
export namespace battlecode.schema{
export class GameMap {
  bb: flatbuffers.ByteBuffer|null = null;

  bb_pos:number = 0;
/**
 * @param number i
 * @param flatbuffers.ByteBuffer bb
 * @returns GameMap
 */
__init(i:number, bb:flatbuffers.ByteBuffer):GameMap {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param GameMap= obj
 * @returns GameMap
 */
static getRootAsGameMap(bb:flatbuffers.ByteBuffer, obj?:GameMap):GameMap {
  return (obj || new GameMap()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param GameMap= obj
 * @returns GameMap
 */
static getSizePrefixedRootAsGameMap(bb:flatbuffers.ByteBuffer, obj?:GameMap):GameMap {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new GameMap()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * The name of a map.
 *
 * @param flatbuffers.Encoding= optionalEncoding
 * @returns string|Uint8Array|null
 */
name():string|null
name(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
name(optionalEncoding?:any):string|Uint8Array|null {
  var offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
};

/**
 * The bottom corner of the map.
 *
 * @param battlecode.schema.Vec= obj
 * @returns battlecode.schema.Vec|null
 */
minCorner(obj?:battlecode.schema.Vec):battlecode.schema.Vec|null {
  var offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? (obj || new battlecode.schema.Vec()).__init(this.bb_pos + offset, this.bb!) : null;
};

/**
 * The top corner of the map.
 *
 * @param battlecode.schema.Vec= obj
 * @returns battlecode.schema.Vec|null
 */
maxCorner(obj?:battlecode.schema.Vec):battlecode.schema.Vec|null {
  var offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? (obj || new battlecode.schema.Vec()).__init(this.bb_pos + offset, this.bb!) : null;
};

/**
 * The bodies on the map.
 *
 * @param battlecode.schema.SpawnedBodyTable= obj
 * @returns battlecode.schema.SpawnedBodyTable|null
 */
bodies(obj?:battlecode.schema.SpawnedBodyTable):battlecode.schema.SpawnedBodyTable|null {
  var offset = this.bb!.__offset(this.bb_pos, 10);
  return offset ? (obj || new battlecode.schema.SpawnedBodyTable()).__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!) : null;
};

/**
 * The random seed of the map.
 *
 * @returns number
 */
randomSeed():number {
  var offset = this.bb!.__offset(this.bb_pos, 12);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
};

/**
 * Whether locations are passable
 *
 * @param number index
 * @returns boolean
 */
passable(index: number):boolean|null {
  var offset = this.bb!.__offset(this.bb_pos, 14);
  return offset ? !!this.bb!.readInt8(this.bb!.__vector(this.bb_pos + offset) + index) : false;
};

/**
 * @returns number
 */
passableLength():number {
  var offset = this.bb!.__offset(this.bb_pos, 14);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
};

/**
 * @returns Int8Array
 */
passableArray():Int8Array|null {
  var offset = this.bb!.__offset(this.bb_pos, 14);
  return offset ? new Int8Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
};

/**
 * @param flatbuffers.Builder builder
 */
static startGameMap(builder:flatbuffers.Builder) {
  builder.startObject(6);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset nameOffset
 */
static addName(builder:flatbuffers.Builder, nameOffset:flatbuffers.Offset) {
  builder.addFieldOffset(0, nameOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset minCornerOffset
 */
static addMinCorner(builder:flatbuffers.Builder, minCornerOffset:flatbuffers.Offset) {
  builder.addFieldStruct(1, minCornerOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset maxCornerOffset
 */
static addMaxCorner(builder:flatbuffers.Builder, maxCornerOffset:flatbuffers.Offset) {
  builder.addFieldStruct(2, maxCornerOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset bodiesOffset
 */
static addBodies(builder:flatbuffers.Builder, bodiesOffset:flatbuffers.Offset) {
  builder.addFieldOffset(3, bodiesOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param number randomSeed
 */
static addRandomSeed(builder:flatbuffers.Builder, randomSeed:number) {
  builder.addFieldInt32(4, randomSeed, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset passableOffset
 */
static addPassable(builder:flatbuffers.Builder, passableOffset:flatbuffers.Offset) {
  builder.addFieldOffset(5, passableOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param Array.<boolean> data
 * @returns flatbuffers.Offset
 */
static createPassableVector(builder:flatbuffers.Builder, data:boolean[]):flatbuffers.Offset {
  builder.startVector(1, data.length, 1);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addInt8(+data[i]);
  }
  return builder.endVector();
};

/**
 * @param flatbuffers.Builder builder
 * @param number numElems
 */
static startPassableVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(1, numElems, 1);
};

/**
 * @param flatbuffers.Builder builder
 * @returns flatbuffers.Offset
 */
static endGameMap(builder:flatbuffers.Builder):flatbuffers.Offset {
  var offset = builder.endObject();
  return offset;
};

}
}
/**
 * Metadata about all bodies of a particular type.
 *
 * @constructor
 */
export namespace battlecode.schema{
export class BodyTypeMetadata {
  bb: flatbuffers.ByteBuffer|null = null;

  bb_pos:number = 0;
/**
 * @param number i
 * @param flatbuffers.ByteBuffer bb
 * @returns BodyTypeMetadata
 */
__init(i:number, bb:flatbuffers.ByteBuffer):BodyTypeMetadata {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param BodyTypeMetadata= obj
 * @returns BodyTypeMetadata
 */
static getRootAsBodyTypeMetadata(bb:flatbuffers.ByteBuffer, obj?:BodyTypeMetadata):BodyTypeMetadata {
  return (obj || new BodyTypeMetadata()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param BodyTypeMetadata= obj
 * @returns BodyTypeMetadata
 */
static getSizePrefixedRootAsBodyTypeMetadata(bb:flatbuffers.ByteBuffer, obj?:BodyTypeMetadata):BodyTypeMetadata {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new BodyTypeMetadata()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * The relevant type.
 *
 * @returns battlecode.schema.BodyType
 */
type():battlecode.schema.BodyType {
  var offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? /**  */ (this.bb!.readInt8(this.bb_pos + offset)) : battlecode.schema.BodyType.ENLIGHTENMENT_CENTER;
};

/**
 * The spawn source.
 *
 * @returns battlecode.schema.BodyType
 */
spawnSource():battlecode.schema.BodyType {
  var offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? /**  */ (this.bb!.readInt8(this.bb_pos + offset)) : battlecode.schema.BodyType.ENLIGHTENMENT_CENTER;
};

/**
 * The cost of the type, in influence.
 *
 * @returns number
 */
cost():number {
  var offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
};

/**
 * The current conviction
 *
 * @returns number
 */
conviction():number {
  var offset = this.bb!.__offset(this.bb_pos, 10);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
};

/**
 * The current power, in influence
 *
 * @returns number
 */
power():number {
  var offset = this.bb!.__offset(this.bb_pos, 12);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
};

/**
 * The number of cooldowns between every two actions.
 *
 * @returns number
 */
actionCooldown():number {
  var offset = this.bb!.__offset(this.bb_pos, 14);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
};

/**
 * The maximum distance squared this type can sense other robots.
 *
 * @returns number
 */
visionRange():number {
  var offset = this.bb!.__offset(this.bb_pos, 16);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
};

/**
 * The maximum distance squared this type can affect other robots.
 *
 * @returns number
 */
actionRange():number {
  var offset = this.bb!.__offset(this.bb_pos, 18);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
};

/**
 * @param flatbuffers.Builder builder
 */
static startBodyTypeMetadata(builder:flatbuffers.Builder) {
  builder.startObject(8);
};

/**
 * @param flatbuffers.Builder builder
 * @param battlecode.schema.BodyType type
 */
static addType(builder:flatbuffers.Builder, type:battlecode.schema.BodyType) {
  builder.addFieldInt8(0, type, battlecode.schema.BodyType.ENLIGHTENMENT_CENTER);
};

/**
 * @param flatbuffers.Builder builder
 * @param battlecode.schema.BodyType spawnSource
 */
static addSpawnSource(builder:flatbuffers.Builder, spawnSource:battlecode.schema.BodyType) {
  builder.addFieldInt8(1, spawnSource, battlecode.schema.BodyType.ENLIGHTENMENT_CENTER);
};

/**
 * @param flatbuffers.Builder builder
 * @param number cost
 */
static addCost(builder:flatbuffers.Builder, cost:number) {
  builder.addFieldInt32(2, cost, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param number conviction
 */
static addConviction(builder:flatbuffers.Builder, conviction:number) {
  builder.addFieldInt32(3, conviction, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param number power
 */
static addPower(builder:flatbuffers.Builder, power:number) {
  builder.addFieldInt32(4, power, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param number actionCooldown
 */
static addActionCooldown(builder:flatbuffers.Builder, actionCooldown:number) {
  builder.addFieldInt32(5, actionCooldown, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param number visionRange
 */
static addVisionRange(builder:flatbuffers.Builder, visionRange:number) {
  builder.addFieldInt32(6, visionRange, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param number actionRange
 */
static addActionRange(builder:flatbuffers.Builder, actionRange:number) {
  builder.addFieldInt32(7, actionRange, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @returns flatbuffers.Offset
 */
static endBodyTypeMetadata(builder:flatbuffers.Builder):flatbuffers.Offset {
  var offset = builder.endObject();
  return offset;
};

static createBodyTypeMetadata(builder:flatbuffers.Builder, type:battlecode.schema.BodyType, spawnSource:battlecode.schema.BodyType, cost:number, conviction:number, power:number, actionCooldown:number, visionRange:number, actionRange:number):flatbuffers.Offset {
  BodyTypeMetadata.startBodyTypeMetadata(builder);
  BodyTypeMetadata.addType(builder, type);
  BodyTypeMetadata.addSpawnSource(builder, spawnSource);
  BodyTypeMetadata.addCost(builder, cost);
  BodyTypeMetadata.addConviction(builder, conviction);
  BodyTypeMetadata.addPower(builder, power);
  BodyTypeMetadata.addActionCooldown(builder, actionCooldown);
  BodyTypeMetadata.addVisionRange(builder, visionRange);
  BodyTypeMetadata.addActionRange(builder, actionRange);
  return BodyTypeMetadata.endBodyTypeMetadata(builder);
}
}
}
/**
 * Data relevant to a particular team.
 *
 * @constructor
 */
export namespace battlecode.schema{
export class TeamData {
  bb: flatbuffers.ByteBuffer|null = null;

  bb_pos:number = 0;
/**
 * @param number i
 * @param flatbuffers.ByteBuffer bb
 * @returns TeamData
 */
__init(i:number, bb:flatbuffers.ByteBuffer):TeamData {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param TeamData= obj
 * @returns TeamData
 */
static getRootAsTeamData(bb:flatbuffers.ByteBuffer, obj?:TeamData):TeamData {
  return (obj || new TeamData()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param TeamData= obj
 * @returns TeamData
 */
static getSizePrefixedRootAsTeamData(bb:flatbuffers.ByteBuffer, obj?:TeamData):TeamData {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new TeamData()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * The name of the team.
 *
 * @param flatbuffers.Encoding= optionalEncoding
 * @returns string|Uint8Array|null
 */
name():string|null
name(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
name(optionalEncoding?:any):string|Uint8Array|null {
  var offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
};

/**
 * The java package the team uses.
 *
 * @param flatbuffers.Encoding= optionalEncoding
 * @returns string|Uint8Array|null
 */
packageName():string|null
packageName(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
packageName(optionalEncoding?:any):string|Uint8Array|null {
  var offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
};

/**
 * The ID of the team this data pertains to.
 *
 * @returns number
 */
teamID():number {
  var offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? this.bb!.readInt8(this.bb_pos + offset) : 0;
};

/**
 * @param flatbuffers.Builder builder
 */
static startTeamData(builder:flatbuffers.Builder) {
  builder.startObject(3);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset nameOffset
 */
static addName(builder:flatbuffers.Builder, nameOffset:flatbuffers.Offset) {
  builder.addFieldOffset(0, nameOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset packageNameOffset
 */
static addPackageName(builder:flatbuffers.Builder, packageNameOffset:flatbuffers.Offset) {
  builder.addFieldOffset(1, packageNameOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param number teamID
 */
static addTeamID(builder:flatbuffers.Builder, teamID:number) {
  builder.addFieldInt8(2, teamID, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @returns flatbuffers.Offset
 */
static endTeamData(builder:flatbuffers.Builder):flatbuffers.Offset {
  var offset = builder.endObject();
  return offset;
};

static createTeamData(builder:flatbuffers.Builder, nameOffset:flatbuffers.Offset, packageNameOffset:flatbuffers.Offset, teamID:number):flatbuffers.Offset {
  TeamData.startTeamData(builder);
  TeamData.addName(builder, nameOffset);
  TeamData.addPackageName(builder, packageNameOffset);
  TeamData.addTeamID(builder, teamID);
  return TeamData.endTeamData(builder);
}
}
}
/**
 * The first event sent in the game. Contains all metadata about the game.
 *
 * @constructor
 */
export namespace battlecode.schema{
export class GameHeader {
  bb: flatbuffers.ByteBuffer|null = null;

  bb_pos:number = 0;
/**
 * @param number i
 * @param flatbuffers.ByteBuffer bb
 * @returns GameHeader
 */
__init(i:number, bb:flatbuffers.ByteBuffer):GameHeader {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param GameHeader= obj
 * @returns GameHeader
 */
static getRootAsGameHeader(bb:flatbuffers.ByteBuffer, obj?:GameHeader):GameHeader {
  return (obj || new GameHeader()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param GameHeader= obj
 * @returns GameHeader
 */
static getSizePrefixedRootAsGameHeader(bb:flatbuffers.ByteBuffer, obj?:GameHeader):GameHeader {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new GameHeader()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * The version of the spec this game complies with.
 *
 * @param flatbuffers.Encoding= optionalEncoding
 * @returns string|Uint8Array|null
 */
specVersion():string|null
specVersion(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
specVersion(optionalEncoding?:any):string|Uint8Array|null {
  var offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
};

/**
 * The teams participating in the game.
 *
 * @param number index
 * @param battlecode.schema.TeamData= obj
 * @returns battlecode.schema.TeamData
 */
teams(index: number, obj?:battlecode.schema.TeamData):battlecode.schema.TeamData|null {
  var offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? (obj || new battlecode.schema.TeamData()).__init(this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4), this.bb!) : null;
};

/**
 * @returns number
 */
teamsLength():number {
  var offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
};

/**
 * Information about all body types in the game.
 *
 * @param number index
 * @param battlecode.schema.BodyTypeMetadata= obj
 * @returns battlecode.schema.BodyTypeMetadata
 */
bodyTypeMetadata(index: number, obj?:battlecode.schema.BodyTypeMetadata):battlecode.schema.BodyTypeMetadata|null {
  var offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? (obj || new battlecode.schema.BodyTypeMetadata()).__init(this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4), this.bb!) : null;
};

/**
 * @returns number
 */
bodyTypeMetadataLength():number {
  var offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
};

/**
 * @param flatbuffers.Builder builder
 */
static startGameHeader(builder:flatbuffers.Builder) {
  builder.startObject(3);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset specVersionOffset
 */
static addSpecVersion(builder:flatbuffers.Builder, specVersionOffset:flatbuffers.Offset) {
  builder.addFieldOffset(0, specVersionOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset teamsOffset
 */
static addTeams(builder:flatbuffers.Builder, teamsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(1, teamsOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param Array.<flatbuffers.Offset> data
 * @returns flatbuffers.Offset
 */
static createTeamsVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]);
  }
  return builder.endVector();
};

/**
 * @param flatbuffers.Builder builder
 * @param number numElems
 */
static startTeamsVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset bodyTypeMetadataOffset
 */
static addBodyTypeMetadata(builder:flatbuffers.Builder, bodyTypeMetadataOffset:flatbuffers.Offset) {
  builder.addFieldOffset(2, bodyTypeMetadataOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param Array.<flatbuffers.Offset> data
 * @returns flatbuffers.Offset
 */
static createBodyTypeMetadataVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]);
  }
  return builder.endVector();
};

/**
 * @param flatbuffers.Builder builder
 * @param number numElems
 */
static startBodyTypeMetadataVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
};

/**
 * @param flatbuffers.Builder builder
 * @returns flatbuffers.Offset
 */
static endGameHeader(builder:flatbuffers.Builder):flatbuffers.Offset {
  var offset = builder.endObject();
  return offset;
};

static createGameHeader(builder:flatbuffers.Builder, specVersionOffset:flatbuffers.Offset, teamsOffset:flatbuffers.Offset, bodyTypeMetadataOffset:flatbuffers.Offset):flatbuffers.Offset {
  GameHeader.startGameHeader(builder);
  GameHeader.addSpecVersion(builder, specVersionOffset);
  GameHeader.addTeams(builder, teamsOffset);
  GameHeader.addBodyTypeMetadata(builder, bodyTypeMetadataOffset);
  return GameHeader.endGameHeader(builder);
}
}
}
/**
 * The final event sent in the game.
 *
 * @constructor
 */
export namespace battlecode.schema{
export class GameFooter {
  bb: flatbuffers.ByteBuffer|null = null;

  bb_pos:number = 0;
/**
 * @param number i
 * @param flatbuffers.ByteBuffer bb
 * @returns GameFooter
 */
__init(i:number, bb:flatbuffers.ByteBuffer):GameFooter {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param GameFooter= obj
 * @returns GameFooter
 */
static getRootAsGameFooter(bb:flatbuffers.ByteBuffer, obj?:GameFooter):GameFooter {
  return (obj || new GameFooter()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param GameFooter= obj
 * @returns GameFooter
 */
static getSizePrefixedRootAsGameFooter(bb:flatbuffers.ByteBuffer, obj?:GameFooter):GameFooter {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new GameFooter()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * The ID of the winning team of the game.
 *
 * @returns number
 */
winner():number {
  var offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.readInt8(this.bb_pos + offset) : 0;
};

/**
 * @param flatbuffers.Builder builder
 */
static startGameFooter(builder:flatbuffers.Builder) {
  builder.startObject(1);
};

/**
 * @param flatbuffers.Builder builder
 * @param number winner
 */
static addWinner(builder:flatbuffers.Builder, winner:number) {
  builder.addFieldInt8(0, winner, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @returns flatbuffers.Offset
 */
static endGameFooter(builder:flatbuffers.Builder):flatbuffers.Offset {
  var offset = builder.endObject();
  return offset;
};

static createGameFooter(builder:flatbuffers.Builder, winner:number):flatbuffers.Offset {
  GameFooter.startGameFooter(builder);
  GameFooter.addWinner(builder, winner);
  return GameFooter.endGameFooter(builder);
}
}
}
/**
 * Sent to start a match.
 *
 * @constructor
 */
export namespace battlecode.schema{
export class MatchHeader {
  bb: flatbuffers.ByteBuffer|null = null;

  bb_pos:number = 0;
/**
 * @param number i
 * @param flatbuffers.ByteBuffer bb
 * @returns MatchHeader
 */
__init(i:number, bb:flatbuffers.ByteBuffer):MatchHeader {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param MatchHeader= obj
 * @returns MatchHeader
 */
static getRootAsMatchHeader(bb:flatbuffers.ByteBuffer, obj?:MatchHeader):MatchHeader {
  return (obj || new MatchHeader()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param MatchHeader= obj
 * @returns MatchHeader
 */
static getSizePrefixedRootAsMatchHeader(bb:flatbuffers.ByteBuffer, obj?:MatchHeader):MatchHeader {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new MatchHeader()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * The map the match was played on.
 *
 * @param battlecode.schema.GameMap= obj
 * @returns battlecode.schema.GameMap|null
 */
map(obj?:battlecode.schema.GameMap):battlecode.schema.GameMap|null {
  var offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? (obj || new battlecode.schema.GameMap()).__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!) : null;
};

/**
 * The maximum number of rounds in this match.
 *
 * @returns number
 */
maxRounds():number {
  var offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
};

/**
 * @param flatbuffers.Builder builder
 */
static startMatchHeader(builder:flatbuffers.Builder) {
  builder.startObject(2);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset mapOffset
 */
static addMap(builder:flatbuffers.Builder, mapOffset:flatbuffers.Offset) {
  builder.addFieldOffset(0, mapOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param number maxRounds
 */
static addMaxRounds(builder:flatbuffers.Builder, maxRounds:number) {
  builder.addFieldInt32(1, maxRounds, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @returns flatbuffers.Offset
 */
static endMatchHeader(builder:flatbuffers.Builder):flatbuffers.Offset {
  var offset = builder.endObject();
  return offset;
};

static createMatchHeader(builder:flatbuffers.Builder, mapOffset:flatbuffers.Offset, maxRounds:number):flatbuffers.Offset {
  MatchHeader.startMatchHeader(builder);
  MatchHeader.addMap(builder, mapOffset);
  MatchHeader.addMaxRounds(builder, maxRounds);
  return MatchHeader.endMatchHeader(builder);
}
}
}
/**
 * Sent to end a match.
 *
 * @constructor
 */
export namespace battlecode.schema{
export class MatchFooter {
  bb: flatbuffers.ByteBuffer|null = null;

  bb_pos:number = 0;
/**
 * @param number i
 * @param flatbuffers.ByteBuffer bb
 * @returns MatchFooter
 */
__init(i:number, bb:flatbuffers.ByteBuffer):MatchFooter {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param MatchFooter= obj
 * @returns MatchFooter
 */
static getRootAsMatchFooter(bb:flatbuffers.ByteBuffer, obj?:MatchFooter):MatchFooter {
  return (obj || new MatchFooter()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param MatchFooter= obj
 * @returns MatchFooter
 */
static getSizePrefixedRootAsMatchFooter(bb:flatbuffers.ByteBuffer, obj?:MatchFooter):MatchFooter {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new MatchFooter()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * The ID of the winning team.
 *
 * @returns number
 */
winner():number {
  var offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.readInt8(this.bb_pos + offset) : 0;
};

/**
 * The number of rounds played.
 *
 * @returns number
 */
totalRounds():number {
  var offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
};

/**
 * @param flatbuffers.Builder builder
 */
static startMatchFooter(builder:flatbuffers.Builder) {
  builder.startObject(2);
};

/**
 * @param flatbuffers.Builder builder
 * @param number winner
 */
static addWinner(builder:flatbuffers.Builder, winner:number) {
  builder.addFieldInt8(0, winner, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param number totalRounds
 */
static addTotalRounds(builder:flatbuffers.Builder, totalRounds:number) {
  builder.addFieldInt32(1, totalRounds, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @returns flatbuffers.Offset
 */
static endMatchFooter(builder:flatbuffers.Builder):flatbuffers.Offset {
  var offset = builder.endObject();
  return offset;
};

static createMatchFooter(builder:flatbuffers.Builder, winner:number, totalRounds:number):flatbuffers.Offset {
  MatchFooter.startMatchFooter(builder);
  MatchFooter.addWinner(builder, winner);
  MatchFooter.addTotalRounds(builder, totalRounds);
  return MatchFooter.endMatchFooter(builder);
}
}
}
/**
 * A single time-step in a Game.
 * The bulk of the data in the file is stored in tables like this.
 * Note that a struct-of-arrays format is more space efficient than an array-
 * of-structs.
 *
 * @constructor
 */
export namespace battlecode.schema{
export class Round {
  bb: flatbuffers.ByteBuffer|null = null;

  bb_pos:number = 0;
/**
 * @param number i
 * @param flatbuffers.ByteBuffer bb
 * @returns Round
 */
__init(i:number, bb:flatbuffers.ByteBuffer):Round {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param Round= obj
 * @returns Round
 */
static getRootAsRound(bb:flatbuffers.ByteBuffer, obj?:Round):Round {
  return (obj || new Round()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param Round= obj
 * @returns Round
 */
static getSizePrefixedRootAsRound(bb:flatbuffers.ByteBuffer, obj?:Round):Round {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new Round()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * The IDs of teams in the Game.
 *
 * @param number index
 * @returns number
 */
teamIDs(index: number):number|null {
  var offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.readInt32(this.bb!.__vector(this.bb_pos + offset) + index * 4) : 0;
};

/**
 * @returns number
 */
teamIDsLength():number {
  var offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
};

/**
 * @returns Int32Array
 */
teamIDsArray():Int32Array|null {
  var offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? new Int32Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
};

/**
 * The bids of the teams.
 *
 * @param number index
 * @returns number
 */
teamBids(index: number):number|null {
  var offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.readInt32(this.bb!.__vector(this.bb_pos + offset) + index * 4) : 0;
};

/**
 * @returns number
 */
teamBidsLength():number {
  var offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
};

/**
 * @returns Int32Array
 */
teamBidsArray():Int32Array|null {
  var offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? new Int32Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
};

/**
 * The IDs of bodies that moved.
 *
 * @param number index
 * @returns number
 */
movedIDs(index: number):number|null {
  var offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? this.bb!.readInt32(this.bb!.__vector(this.bb_pos + offset) + index * 4) : 0;
};

/**
 * @returns number
 */
movedIDsLength():number {
  var offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
};

/**
 * @returns Int32Array
 */
movedIDsArray():Int32Array|null {
  var offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? new Int32Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
};

/**
 * The new locations of bodies that have moved.
 *
 * @param battlecode.schema.VecTable= obj
 * @returns battlecode.schema.VecTable|null
 */
movedLocs(obj?:battlecode.schema.VecTable):battlecode.schema.VecTable|null {
  var offset = this.bb!.__offset(this.bb_pos, 10);
  return offset ? (obj || new battlecode.schema.VecTable()).__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!) : null;
};

/**
 * New bodies.
 *
 * @param battlecode.schema.SpawnedBodyTable= obj
 * @returns battlecode.schema.SpawnedBodyTable|null
 */
spawnedBodies(obj?:battlecode.schema.SpawnedBodyTable):battlecode.schema.SpawnedBodyTable|null {
  var offset = this.bb!.__offset(this.bb_pos, 12);
  return offset ? (obj || new battlecode.schema.SpawnedBodyTable()).__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!) : null;
};

/**
 * The IDs of bodies that died (drowned units and shot drones).
 *
 * @param number index
 * @returns number
 */
diedIDs(index: number):number|null {
  var offset = this.bb!.__offset(this.bb_pos, 14);
  return offset ? this.bb!.readInt32(this.bb!.__vector(this.bb_pos + offset) + index * 4) : 0;
};

/**
 * @returns number
 */
diedIDsLength():number {
  var offset = this.bb!.__offset(this.bb_pos, 14);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
};

/**
 * @returns Int32Array
 */
diedIDsArray():Int32Array|null {
  var offset = this.bb!.__offset(this.bb_pos, 14);
  return offset ? new Int32Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
};

/**
 * The IDs of robots that performed actions.
 * IDs may repeat.
 *
 * @param number index
 * @returns number
 */
actionIDs(index: number):number|null {
  var offset = this.bb!.__offset(this.bb_pos, 16);
  return offset ? this.bb!.readInt32(this.bb!.__vector(this.bb_pos + offset) + index * 4) : 0;
};

/**
 * @returns number
 */
actionIDsLength():number {
  var offset = this.bb!.__offset(this.bb_pos, 16);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
};

/**
 * @returns Int32Array
 */
actionIDsArray():Int32Array|null {
  var offset = this.bb!.__offset(this.bb_pos, 16);
  return offset ? new Int32Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
};

/**
 * The actions performed. These actions allow us to track how much soup or dirt a body carries.
 *
 * @param number index
 * @returns battlecode.schema.Action
 */
actions(index: number):battlecode.schema.Action|null {
  var offset = this.bb!.__offset(this.bb_pos, 18);
  return offset ? /**  */ (this.bb!.readInt8(this.bb!.__vector(this.bb_pos + offset) + index)) : /**  */ (0);
};

/**
 * @returns number
 */
actionsLength():number {
  var offset = this.bb!.__offset(this.bb_pos, 18);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
};

/**
 * @returns Int8Array
 */
actionsArray():Int8Array|null {
  var offset = this.bb!.__offset(this.bb_pos, 18);
  return offset ? new Int8Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
};

/**
 * The 'targets' of the performed actions. Actions without targets may have
 * any target (typically 0).
 *
 * @param number index
 * @returns number
 */
actionTargets(index: number):number|null {
  var offset = this.bb!.__offset(this.bb_pos, 20);
  return offset ? this.bb!.readInt32(this.bb!.__vector(this.bb_pos + offset) + index * 4) : 0;
};

/**
 * @returns number
 */
actionTargetsLength():number {
  var offset = this.bb!.__offset(this.bb_pos, 20);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
};

/**
 * @returns Int32Array
 */
actionTargetsArray():Int32Array|null {
  var offset = this.bb!.__offset(this.bb_pos, 20);
  return offset ? new Int32Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
};

/**
 * The IDs of bodies that set indicator dots
 *
 * @param number index
 * @returns number
 */
indicatorDotIDs(index: number):number|null {
  var offset = this.bb!.__offset(this.bb_pos, 22);
  return offset ? this.bb!.readInt32(this.bb!.__vector(this.bb_pos + offset) + index * 4) : 0;
};

/**
 * @returns number
 */
indicatorDotIDsLength():number {
  var offset = this.bb!.__offset(this.bb_pos, 22);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
};

/**
 * @returns Int32Array
 */
indicatorDotIDsArray():Int32Array|null {
  var offset = this.bb!.__offset(this.bb_pos, 22);
  return offset ? new Int32Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
};

/**
 * The location of the indicator dots
 *
 * @param battlecode.schema.VecTable= obj
 * @returns battlecode.schema.VecTable|null
 */
indicatorDotLocs(obj?:battlecode.schema.VecTable):battlecode.schema.VecTable|null {
  var offset = this.bb!.__offset(this.bb_pos, 24);
  return offset ? (obj || new battlecode.schema.VecTable()).__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!) : null;
};

/**
 * The RGB values of the indicator dots
 *
 * @param battlecode.schema.RGBTable= obj
 * @returns battlecode.schema.RGBTable|null
 */
indicatorDotRGBs(obj?:battlecode.schema.RGBTable):battlecode.schema.RGBTable|null {
  var offset = this.bb!.__offset(this.bb_pos, 26);
  return offset ? (obj || new battlecode.schema.RGBTable()).__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!) : null;
};

/**
 * The IDs of bodies that set indicator lines
 *
 * @param number index
 * @returns number
 */
indicatorLineIDs(index: number):number|null {
  var offset = this.bb!.__offset(this.bb_pos, 28);
  return offset ? this.bb!.readInt32(this.bb!.__vector(this.bb_pos + offset) + index * 4) : 0;
};

/**
 * @returns number
 */
indicatorLineIDsLength():number {
  var offset = this.bb!.__offset(this.bb_pos, 28);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
};

/**
 * @returns Int32Array
 */
indicatorLineIDsArray():Int32Array|null {
  var offset = this.bb!.__offset(this.bb_pos, 28);
  return offset ? new Int32Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
};

/**
 * The start location of the indicator lines
 *
 * @param battlecode.schema.VecTable= obj
 * @returns battlecode.schema.VecTable|null
 */
indicatorLineStartLocs(obj?:battlecode.schema.VecTable):battlecode.schema.VecTable|null {
  var offset = this.bb!.__offset(this.bb_pos, 30);
  return offset ? (obj || new battlecode.schema.VecTable()).__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!) : null;
};

/**
 * The end location of the indicator lines
 *
 * @param battlecode.schema.VecTable= obj
 * @returns battlecode.schema.VecTable|null
 */
indicatorLineEndLocs(obj?:battlecode.schema.VecTable):battlecode.schema.VecTable|null {
  var offset = this.bb!.__offset(this.bb_pos, 32);
  return offset ? (obj || new battlecode.schema.VecTable()).__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!) : null;
};

/**
 * The RGB values of the indicator lines
 *
 * @param battlecode.schema.RGBTable= obj
 * @returns battlecode.schema.RGBTable|null
 */
indicatorLineRGBs(obj?:battlecode.schema.RGBTable):battlecode.schema.RGBTable|null {
  var offset = this.bb!.__offset(this.bb_pos, 34);
  return offset ? (obj || new battlecode.schema.RGBTable()).__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!) : null;
};

/**
 * All logs sent this round.
 * Messages from a particular robot in this round start on a new line, and
 * have a header:
 * '[' $TEAM ':' $ROBOTTYPE '#' $ID '@' $ROUND '] '
 * $TEAM = 'A' | 'B'
 * $ROBOTTYPE = 'HQ' | 'VAPORATOR' | 'LANDSCAPER' 
 *            | 'DELIVERY_DRONE' | 'REFINERY' | 'MINER' | other names...
 * $ID = a number
 * $ROUND = a number
 * The header is not necessarily followed by a newline.
 * This header should only be sent once per robot per round (although
 * players may forge it, so don't crash if you get strange input.)
 *
 * You should try to only read this value once, and cache it. Reading
 * strings from a flatbuffer is much less efficient than reading other
 * buffers, because they need to be copied into an environment-provided
 * buffer and validated.
 *
 * (haha i guess you can never really escape string parsing can you)
 *
 * @param flatbuffers.Encoding= optionalEncoding
 * @returns string|Uint8Array|null
 */
logs():string|null
logs(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
logs(optionalEncoding?:any):string|Uint8Array|null {
  var offset = this.bb!.__offset(this.bb_pos, 36);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
};

/**
 * The first sent Round in a match should have index 1. (The starting state,
 * created by the MatchHeader, can be thought to have index 0.)
 * It should increase by one for each following round.
 *
 * @returns number
 */
roundID():number {
  var offset = this.bb!.__offset(this.bb_pos, 38);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
};

/**
 * The IDs of player bodies.
 *
 * @param number index
 * @returns number
 */
bytecodeIDs(index: number):number|null {
  var offset = this.bb!.__offset(this.bb_pos, 40);
  return offset ? this.bb!.readInt32(this.bb!.__vector(this.bb_pos + offset) + index * 4) : 0;
};

/**
 * @returns number
 */
bytecodeIDsLength():number {
  var offset = this.bb!.__offset(this.bb_pos, 40);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
};

/**
 * @returns Int32Array
 */
bytecodeIDsArray():Int32Array|null {
  var offset = this.bb!.__offset(this.bb_pos, 40);
  return offset ? new Int32Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
};

/**
 * The bytecodes used by the player bodies.
 *
 * @param number index
 * @returns number
 */
bytecodesUsed(index: number):number|null {
  var offset = this.bb!.__offset(this.bb_pos, 42);
  return offset ? this.bb!.readInt32(this.bb!.__vector(this.bb_pos + offset) + index * 4) : 0;
};

/**
 * @returns number
 */
bytecodesUsedLength():number {
  var offset = this.bb!.__offset(this.bb_pos, 42);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
};

/**
 * @returns Int32Array
 */
bytecodesUsedArray():Int32Array|null {
  var offset = this.bb!.__offset(this.bb_pos, 42);
  return offset ? new Int32Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
};

/**
 * @param flatbuffers.Builder builder
 */
static startRound(builder:flatbuffers.Builder) {
  builder.startObject(20);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset teamIDsOffset
 */
static addTeamIDs(builder:flatbuffers.Builder, teamIDsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(0, teamIDsOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param Array.<number> data
 * @returns flatbuffers.Offset
 */
static createTeamIDsVector(builder:flatbuffers.Builder, data:number[]|Int32Array):flatbuffers.Offset;
/**
 * @deprecated This Uint8Array overload will be removed in the future.
 */
static createTeamIDsVector(builder:flatbuffers.Builder, data:number[]|Uint8Array):flatbuffers.Offset;
static createTeamIDsVector(builder:flatbuffers.Builder, data:number[]|Int32Array|Uint8Array):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addInt32(data[i]);
  }
  return builder.endVector();
};

/**
 * @param flatbuffers.Builder builder
 * @param number numElems
 */
static startTeamIDsVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset teamBidsOffset
 */
static addTeamBids(builder:flatbuffers.Builder, teamBidsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(1, teamBidsOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param Array.<number> data
 * @returns flatbuffers.Offset
 */
static createTeamBidsVector(builder:flatbuffers.Builder, data:number[]|Int32Array):flatbuffers.Offset;
/**
 * @deprecated This Uint8Array overload will be removed in the future.
 */
static createTeamBidsVector(builder:flatbuffers.Builder, data:number[]|Uint8Array):flatbuffers.Offset;
static createTeamBidsVector(builder:flatbuffers.Builder, data:number[]|Int32Array|Uint8Array):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addInt32(data[i]);
  }
  return builder.endVector();
};

/**
 * @param flatbuffers.Builder builder
 * @param number numElems
 */
static startTeamBidsVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset movedIDsOffset
 */
static addMovedIDs(builder:flatbuffers.Builder, movedIDsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(2, movedIDsOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param Array.<number> data
 * @returns flatbuffers.Offset
 */
static createMovedIDsVector(builder:flatbuffers.Builder, data:number[]|Int32Array):flatbuffers.Offset;
/**
 * @deprecated This Uint8Array overload will be removed in the future.
 */
static createMovedIDsVector(builder:flatbuffers.Builder, data:number[]|Uint8Array):flatbuffers.Offset;
static createMovedIDsVector(builder:flatbuffers.Builder, data:number[]|Int32Array|Uint8Array):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addInt32(data[i]);
  }
  return builder.endVector();
};

/**
 * @param flatbuffers.Builder builder
 * @param number numElems
 */
static startMovedIDsVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset movedLocsOffset
 */
static addMovedLocs(builder:flatbuffers.Builder, movedLocsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(3, movedLocsOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset spawnedBodiesOffset
 */
static addSpawnedBodies(builder:flatbuffers.Builder, spawnedBodiesOffset:flatbuffers.Offset) {
  builder.addFieldOffset(4, spawnedBodiesOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset diedIDsOffset
 */
static addDiedIDs(builder:flatbuffers.Builder, diedIDsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(5, diedIDsOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param Array.<number> data
 * @returns flatbuffers.Offset
 */
static createDiedIDsVector(builder:flatbuffers.Builder, data:number[]|Int32Array):flatbuffers.Offset;
/**
 * @deprecated This Uint8Array overload will be removed in the future.
 */
static createDiedIDsVector(builder:flatbuffers.Builder, data:number[]|Uint8Array):flatbuffers.Offset;
static createDiedIDsVector(builder:flatbuffers.Builder, data:number[]|Int32Array|Uint8Array):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addInt32(data[i]);
  }
  return builder.endVector();
};

/**
 * @param flatbuffers.Builder builder
 * @param number numElems
 */
static startDiedIDsVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset actionIDsOffset
 */
static addActionIDs(builder:flatbuffers.Builder, actionIDsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(6, actionIDsOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param Array.<number> data
 * @returns flatbuffers.Offset
 */
static createActionIDsVector(builder:flatbuffers.Builder, data:number[]|Int32Array):flatbuffers.Offset;
/**
 * @deprecated This Uint8Array overload will be removed in the future.
 */
static createActionIDsVector(builder:flatbuffers.Builder, data:number[]|Uint8Array):flatbuffers.Offset;
static createActionIDsVector(builder:flatbuffers.Builder, data:number[]|Int32Array|Uint8Array):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addInt32(data[i]);
  }
  return builder.endVector();
};

/**
 * @param flatbuffers.Builder builder
 * @param number numElems
 */
static startActionIDsVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset actionsOffset
 */
static addActions(builder:flatbuffers.Builder, actionsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(7, actionsOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param Array.<battlecode.schema.Action> data
 * @returns flatbuffers.Offset
 */
static createActionsVector(builder:flatbuffers.Builder, data:battlecode.schema.Action[]):flatbuffers.Offset {
  builder.startVector(1, data.length, 1);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addInt8(data[i]);
  }
  return builder.endVector();
};

/**
 * @param flatbuffers.Builder builder
 * @param number numElems
 */
static startActionsVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(1, numElems, 1);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset actionTargetsOffset
 */
static addActionTargets(builder:flatbuffers.Builder, actionTargetsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(8, actionTargetsOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param Array.<number> data
 * @returns flatbuffers.Offset
 */
static createActionTargetsVector(builder:flatbuffers.Builder, data:number[]|Int32Array):flatbuffers.Offset;
/**
 * @deprecated This Uint8Array overload will be removed in the future.
 */
static createActionTargetsVector(builder:flatbuffers.Builder, data:number[]|Uint8Array):flatbuffers.Offset;
static createActionTargetsVector(builder:flatbuffers.Builder, data:number[]|Int32Array|Uint8Array):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addInt32(data[i]);
  }
  return builder.endVector();
};

/**
 * @param flatbuffers.Builder builder
 * @param number numElems
 */
static startActionTargetsVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset indicatorDotIDsOffset
 */
static addIndicatorDotIDs(builder:flatbuffers.Builder, indicatorDotIDsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(9, indicatorDotIDsOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param Array.<number> data
 * @returns flatbuffers.Offset
 */
static createIndicatorDotIDsVector(builder:flatbuffers.Builder, data:number[]|Int32Array):flatbuffers.Offset;
/**
 * @deprecated This Uint8Array overload will be removed in the future.
 */
static createIndicatorDotIDsVector(builder:flatbuffers.Builder, data:number[]|Uint8Array):flatbuffers.Offset;
static createIndicatorDotIDsVector(builder:flatbuffers.Builder, data:number[]|Int32Array|Uint8Array):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addInt32(data[i]);
  }
  return builder.endVector();
};

/**
 * @param flatbuffers.Builder builder
 * @param number numElems
 */
static startIndicatorDotIDsVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset indicatorDotLocsOffset
 */
static addIndicatorDotLocs(builder:flatbuffers.Builder, indicatorDotLocsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(10, indicatorDotLocsOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset indicatorDotRGBsOffset
 */
static addIndicatorDotRGBs(builder:flatbuffers.Builder, indicatorDotRGBsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(11, indicatorDotRGBsOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset indicatorLineIDsOffset
 */
static addIndicatorLineIDs(builder:flatbuffers.Builder, indicatorLineIDsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(12, indicatorLineIDsOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param Array.<number> data
 * @returns flatbuffers.Offset
 */
static createIndicatorLineIDsVector(builder:flatbuffers.Builder, data:number[]|Int32Array):flatbuffers.Offset;
/**
 * @deprecated This Uint8Array overload will be removed in the future.
 */
static createIndicatorLineIDsVector(builder:flatbuffers.Builder, data:number[]|Uint8Array):flatbuffers.Offset;
static createIndicatorLineIDsVector(builder:flatbuffers.Builder, data:number[]|Int32Array|Uint8Array):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addInt32(data[i]);
  }
  return builder.endVector();
};

/**
 * @param flatbuffers.Builder builder
 * @param number numElems
 */
static startIndicatorLineIDsVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset indicatorLineStartLocsOffset
 */
static addIndicatorLineStartLocs(builder:flatbuffers.Builder, indicatorLineStartLocsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(13, indicatorLineStartLocsOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset indicatorLineEndLocsOffset
 */
static addIndicatorLineEndLocs(builder:flatbuffers.Builder, indicatorLineEndLocsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(14, indicatorLineEndLocsOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset indicatorLineRGBsOffset
 */
static addIndicatorLineRGBs(builder:flatbuffers.Builder, indicatorLineRGBsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(15, indicatorLineRGBsOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset logsOffset
 */
static addLogs(builder:flatbuffers.Builder, logsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(16, logsOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param number roundID
 */
static addRoundID(builder:flatbuffers.Builder, roundID:number) {
  builder.addFieldInt32(17, roundID, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset bytecodeIDsOffset
 */
static addBytecodeIDs(builder:flatbuffers.Builder, bytecodeIDsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(18, bytecodeIDsOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param Array.<number> data
 * @returns flatbuffers.Offset
 */
static createBytecodeIDsVector(builder:flatbuffers.Builder, data:number[]|Int32Array):flatbuffers.Offset;
/**
 * @deprecated This Uint8Array overload will be removed in the future.
 */
static createBytecodeIDsVector(builder:flatbuffers.Builder, data:number[]|Uint8Array):flatbuffers.Offset;
static createBytecodeIDsVector(builder:flatbuffers.Builder, data:number[]|Int32Array|Uint8Array):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addInt32(data[i]);
  }
  return builder.endVector();
};

/**
 * @param flatbuffers.Builder builder
 * @param number numElems
 */
static startBytecodeIDsVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset bytecodesUsedOffset
 */
static addBytecodesUsed(builder:flatbuffers.Builder, bytecodesUsedOffset:flatbuffers.Offset) {
  builder.addFieldOffset(19, bytecodesUsedOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param Array.<number> data
 * @returns flatbuffers.Offset
 */
static createBytecodesUsedVector(builder:flatbuffers.Builder, data:number[]|Int32Array):flatbuffers.Offset;
/**
 * @deprecated This Uint8Array overload will be removed in the future.
 */
static createBytecodesUsedVector(builder:flatbuffers.Builder, data:number[]|Uint8Array):flatbuffers.Offset;
static createBytecodesUsedVector(builder:flatbuffers.Builder, data:number[]|Int32Array|Uint8Array):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addInt32(data[i]);
  }
  return builder.endVector();
};

/**
 * @param flatbuffers.Builder builder
 * @param number numElems
 */
static startBytecodesUsedVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
};

/**
 * @param flatbuffers.Builder builder
 * @returns flatbuffers.Offset
 */
static endRound(builder:flatbuffers.Builder):flatbuffers.Offset {
  var offset = builder.endObject();
  return offset;
};

}
}
/**
 * Necessary due to flatbuffers requiring unions to be wrapped in tables.
 *
 * @constructor
 */
export namespace battlecode.schema{
export class EventWrapper {
  bb: flatbuffers.ByteBuffer|null = null;

  bb_pos:number = 0;
/**
 * @param number i
 * @param flatbuffers.ByteBuffer bb
 * @returns EventWrapper
 */
__init(i:number, bb:flatbuffers.ByteBuffer):EventWrapper {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param EventWrapper= obj
 * @returns EventWrapper
 */
static getRootAsEventWrapper(bb:flatbuffers.ByteBuffer, obj?:EventWrapper):EventWrapper {
  return (obj || new EventWrapper()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param EventWrapper= obj
 * @returns EventWrapper
 */
static getSizePrefixedRootAsEventWrapper(bb:flatbuffers.ByteBuffer, obj?:EventWrapper):EventWrapper {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new EventWrapper()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * @returns battlecode.schema.Event
 */
eType():battlecode.schema.Event {
  var offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? /**  */ (this.bb!.readUint8(this.bb_pos + offset)) : battlecode.schema.Event.NONE;
};

/**
 * @param flatbuffers.Table obj
 * @returns ?flatbuffers.Table
 */
e<T extends flatbuffers.Table>(obj:T):T|null {
  var offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.__union(obj, this.bb_pos + offset) : null;
};

/**
 * @param flatbuffers.Builder builder
 */
static startEventWrapper(builder:flatbuffers.Builder) {
  builder.startObject(2);
};

/**
 * @param flatbuffers.Builder builder
 * @param battlecode.schema.Event eType
 */
static addEType(builder:flatbuffers.Builder, eType:battlecode.schema.Event) {
  builder.addFieldInt8(0, eType, battlecode.schema.Event.NONE);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset eOffset
 */
static addE(builder:flatbuffers.Builder, eOffset:flatbuffers.Offset) {
  builder.addFieldOffset(1, eOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @returns flatbuffers.Offset
 */
static endEventWrapper(builder:flatbuffers.Builder):flatbuffers.Offset {
  var offset = builder.endObject();
  return offset;
};

static createEventWrapper(builder:flatbuffers.Builder, eType:battlecode.schema.Event, eOffset:flatbuffers.Offset):flatbuffers.Offset {
  EventWrapper.startEventWrapper(builder);
  EventWrapper.addEType(builder, eType);
  EventWrapper.addE(builder, eOffset);
  return EventWrapper.endEventWrapper(builder);
}
}
}
/**
 * If events are not otherwise delimited, this wrapper structure
 * allows a game to be stored in a single buffer.
 * The first event will be a GameHeader; the last event will be a GameFooter.
 * matchHeaders[0] is the index of the 0th match header in the event stream,
 * corresponding to matchFooters[0]. These indices allow quick traversal of
 * the file.
 *
 * @constructor
 */
export namespace battlecode.schema{
export class GameWrapper {
  bb: flatbuffers.ByteBuffer|null = null;

  bb_pos:number = 0;
/**
 * @param number i
 * @param flatbuffers.ByteBuffer bb
 * @returns GameWrapper
 */
__init(i:number, bb:flatbuffers.ByteBuffer):GameWrapper {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param GameWrapper= obj
 * @returns GameWrapper
 */
static getRootAsGameWrapper(bb:flatbuffers.ByteBuffer, obj?:GameWrapper):GameWrapper {
  return (obj || new GameWrapper()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param GameWrapper= obj
 * @returns GameWrapper
 */
static getSizePrefixedRootAsGameWrapper(bb:flatbuffers.ByteBuffer, obj?:GameWrapper):GameWrapper {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new GameWrapper()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * The series of events comprising the game.
 *
 * @param number index
 * @param battlecode.schema.EventWrapper= obj
 * @returns battlecode.schema.EventWrapper
 */
events(index: number, obj?:battlecode.schema.EventWrapper):battlecode.schema.EventWrapper|null {
  var offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? (obj || new battlecode.schema.EventWrapper()).__init(this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4), this.bb!) : null;
};

/**
 * @returns number
 */
eventsLength():number {
  var offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
};

/**
 * The indices of the headers of the matches, in order.
 *
 * @param number index
 * @returns number
 */
matchHeaders(index: number):number|null {
  var offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.readInt32(this.bb!.__vector(this.bb_pos + offset) + index * 4) : 0;
};

/**
 * @returns number
 */
matchHeadersLength():number {
  var offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
};

/**
 * @returns Int32Array
 */
matchHeadersArray():Int32Array|null {
  var offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? new Int32Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
};

/**
 * The indices of the footers of the matches, in order.
 *
 * @param number index
 * @returns number
 */
matchFooters(index: number):number|null {
  var offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? this.bb!.readInt32(this.bb!.__vector(this.bb_pos + offset) + index * 4) : 0;
};

/**
 * @returns number
 */
matchFootersLength():number {
  var offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
};

/**
 * @returns Int32Array
 */
matchFootersArray():Int32Array|null {
  var offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? new Int32Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
};

/**
 * @param flatbuffers.Builder builder
 */
static startGameWrapper(builder:flatbuffers.Builder) {
  builder.startObject(3);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset eventsOffset
 */
static addEvents(builder:flatbuffers.Builder, eventsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(0, eventsOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param Array.<flatbuffers.Offset> data
 * @returns flatbuffers.Offset
 */
static createEventsVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]);
  }
  return builder.endVector();
};

/**
 * @param flatbuffers.Builder builder
 * @param number numElems
 */
static startEventsVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset matchHeadersOffset
 */
static addMatchHeaders(builder:flatbuffers.Builder, matchHeadersOffset:flatbuffers.Offset) {
  builder.addFieldOffset(1, matchHeadersOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param Array.<number> data
 * @returns flatbuffers.Offset
 */
static createMatchHeadersVector(builder:flatbuffers.Builder, data:number[]|Int32Array):flatbuffers.Offset;
/**
 * @deprecated This Uint8Array overload will be removed in the future.
 */
static createMatchHeadersVector(builder:flatbuffers.Builder, data:number[]|Uint8Array):flatbuffers.Offset;
static createMatchHeadersVector(builder:flatbuffers.Builder, data:number[]|Int32Array|Uint8Array):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addInt32(data[i]);
  }
  return builder.endVector();
};

/**
 * @param flatbuffers.Builder builder
 * @param number numElems
 */
static startMatchHeadersVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset matchFootersOffset
 */
static addMatchFooters(builder:flatbuffers.Builder, matchFootersOffset:flatbuffers.Offset) {
  builder.addFieldOffset(2, matchFootersOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param Array.<number> data
 * @returns flatbuffers.Offset
 */
static createMatchFootersVector(builder:flatbuffers.Builder, data:number[]|Int32Array):flatbuffers.Offset;
/**
 * @deprecated This Uint8Array overload will be removed in the future.
 */
static createMatchFootersVector(builder:flatbuffers.Builder, data:number[]|Uint8Array):flatbuffers.Offset;
static createMatchFootersVector(builder:flatbuffers.Builder, data:number[]|Int32Array|Uint8Array):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addInt32(data[i]);
  }
  return builder.endVector();
};

/**
 * @param flatbuffers.Builder builder
 * @param number numElems
 */
static startMatchFootersVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
};

/**
 * @param flatbuffers.Builder builder
 * @returns flatbuffers.Offset
 */
static endGameWrapper(builder:flatbuffers.Builder):flatbuffers.Offset {
  var offset = builder.endObject();
  return offset;
};

static createGameWrapper(builder:flatbuffers.Builder, eventsOffset:flatbuffers.Offset, matchHeadersOffset:flatbuffers.Offset, matchFootersOffset:flatbuffers.Offset):flatbuffers.Offset {
  GameWrapper.startGameWrapper(builder);
  GameWrapper.addEvents(builder, eventsOffset);
  GameWrapper.addMatchHeaders(builder, matchHeadersOffset);
  GameWrapper.addMatchFooters(builder, matchFootersOffset);
  return GameWrapper.endGameWrapper(builder);
}
}
}
